---
icon: i-lucide-folder
---
# fs

> Virtual filesystem abstractions for sandboxed agent execution. Provides in-memory, overlay, and real filesystem implementations with a common interface.

## What It Solves

Agent tooling often needs to read and write files, but different runtimes and safety constraints require different storage backends. The `fs` module gives you a single interface for in-memory, overlay, and real filesystem access. Use it to test file operations, isolate writes, or guard against path traversal.

## When To Use It

- You want to run file operations in tests without touching disk.
- You need copy-on-write behavior so an agent can write safely without modifying the base project.
- You want a sandboxed view of the real filesystem with traversal protection.

## Usage
```ts
import { createFSFromStorage, InMemoryFS, OverlayFS, RealFS } from 'unagent/fs'
```

## API

### InMemoryFS
A fully in-memory filesystem for testing and sandboxed execution.

```ts
const fs = new InMemoryFS()

await fs.mkdir('/workspace', { recursive: true })
await fs.writeFile('/workspace/file.txt', 'Hello')
const content = await fs.readFile('/workspace/file.txt') // "Hello"
```

### OverlayFS
Copy-on-write filesystem that layers changes over a base filesystem. Writes go to the overlay, reads fall through to base.

```ts
const base = new RealFS('/project')
const overlay = new OverlayFS(base)

// Reads from real filesystem
const pkg = await overlay.readFile('/package.json')

// Writes only to overlay, base unchanged
await overlay.writeFile('/package.json', '{}')
```

### RealFS
Wrapper around Node.js filesystem with path sandboxing to prevent traversal attacks.

```ts
const fs = new RealFS('/allowed/path')

await fs.readFile('/subdir/file.txt') // OK: /allowed/path/subdir/file.txt
await fs.readFile('../../etc/passwd') // Throws: path traversal not allowed
```

### createFSFromStorage
Creates a VirtualFS from any Storage adapter (localStorage, unstorage, etc).

```ts
import { createStorage } from 'unstorage'

const storage = createStorage()
const fs = createFSFromStorage({
  getItem: k => storage.getItem(k),
  setItem: (k, v) => storage.setItem(k, v),
  removeItem: k => storage.removeItem(k),
  getKeys: base => storage.getKeys(base),
})
```

### Types
```ts
interface VirtualFS {
  readFile: (path: string) => Promise<string>
  writeFile: (path: string, content: string) => Promise<void>
  exists: (path: string) => Promise<boolean>
  readdir: (path: string) => Promise<string[]>
  mkdir: (path: string, options?: { recursive?: boolean }) => Promise<void>
  rm: (path: string, options?: { recursive?: boolean }) => Promise<void>
  stat: (path: string) => Promise<FileStat>
}

interface FileStat {
  size: number
  isFile: boolean
  isDirectory: boolean
  mtime?: Date
}

interface Storage {
  getItem: (key: string) => Promise<string | null> | string | null
  setItem: (key: string, value: string) => Promise<void> | void
  removeItem: (key: string) => Promise<void> | void
  getKeys: (base?: string) => Promise<string[]> | string[]
}
```

## Examples

### Example: Sandboxed Agent
```ts
import { InMemoryFS, OverlayFS, RealFS } from 'unagent/fs'

// Agent can read real files but writes are isolated
const sandbox = new OverlayFS(new RealFS('/project'))

// Or fully isolated
const isolated = new InMemoryFS()
await isolated.mkdir('/workspace', { recursive: true })
```

## Related
- [Core](/core)
- [exec](/core/exec)
- [link](/core/link)
