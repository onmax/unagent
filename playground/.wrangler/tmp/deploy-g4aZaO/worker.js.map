{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/shared/dist/env.js", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/shared/dist/git.js", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/shared/dist/interpreter-types.js", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/shared/dist/logger/types.js", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/shared/dist/logger/logger.js", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/shared/dist/logger/trace-context.js", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/shared/dist/logger/index.js", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/shared/dist/shell-escape.js", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/shared/dist/types.js", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/shared/dist/ws-types.js", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/shared/dist/errors/codes.js", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/shared/dist/errors/status-map.js", "../../../../node_modules/.pnpm/@cloudflare+containers@0.0.30/node_modules/@cloudflare/containers/src/lib/helpers.ts", "../../../../node_modules/.pnpm/@cloudflare+containers@0.0.30/node_modules/@cloudflare/containers/src/lib/container.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/errors/classes.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/errors/adapter.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/clients/transport/base-transport.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/clients/transport/http-transport.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/clients/transport/ws-transport.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/clients/transport/factory.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/clients/base-client.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/clients/command-client.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/clients/file-client.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/clients/git-client.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/clients/interpreter-client.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/clients/port-client.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/clients/process-client.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/clients/utility-client.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/clients/sandbox-client.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/security.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/interpreter.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/request-handler.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/sse-parser.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/storage-mount/errors.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/storage-mount/credential-detection.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/storage-mount/provider-detection.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/storage-mount/validation.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/version.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/sandbox.ts", "../../../../node_modules/.pnpm/@cloudflare+sandbox@0.7.0/node_modules/@cloudflare/sandbox/src/file-stream.ts", "../../../../node_modules/.pnpm/std-env@3.10.0/node_modules/std-env/dist/index.mjs", "../../../../src/sandbox/adapters.ts", "../../../../src/sandbox/index.ts", "../../../src/worker.ts"],
  "sourceRoot": "/Users/maxi/unjs/unagent/playground/.wrangler/tmp/deploy-g4aZaO",
  "sourcesContent": ["/**\n * Safely extract a string value from an environment object\n *\n * @param env - Environment object with dynamic keys\n * @param key - The environment variable key to access\n * @returns The string value if present and is a string, undefined otherwise\n */\nexport function getEnvString(env, key) {\n    const value = env?.[key];\n    return typeof value === 'string' ? value : undefined;\n}\n/**\n * Filter environment variables object to only include string values.\n * Skips undefined, null, and non-string values.\n *\n * Use this when you only need the defined values (e.g., for per-command env\n * where undefined means \"don't override\").\n *\n * @param envVars - Object that may contain undefined values\n * @returns Clean object with only string values\n */\nexport function filterEnvVars(envVars) {\n    const filtered = {};\n    for (const [key, value] of Object.entries(envVars)) {\n        if (value != null && typeof value === 'string') {\n            filtered[key] = value;\n        }\n    }\n    return filtered;\n}\n/**\n * Partition environment variables into values to set and keys to unset.\n *\n * - String values → toSet (will be exported)\n * - undefined/null → toUnset (will be unset)\n *\n * This enables idiomatic JS patterns where undefined means \"remove\":\n * ```typescript\n * await sandbox.setEnvVars({\n *   API_KEY: 'new-key',        // will be set\n *   OLD_VAR: undefined,        // will be unset\n * });\n * ```\n */\nexport function partitionEnvVars(envVars) {\n    const toSet = {};\n    const toUnset = [];\n    for (const [key, value] of Object.entries(envVars)) {\n        if (value != null && typeof value === 'string') {\n            toSet[key] = value;\n        }\n        else {\n            toUnset.push(key);\n        }\n    }\n    return { toSet, toUnset };\n}\n", "/**\n * Fallback repository name used when URL parsing fails\n */\nexport const FALLBACK_REPO_NAME = 'repository';\n/**\n * Extract repository name from a Git URL\n *\n * Supports multiple URL formats:\n * - HTTPS: https://github.com/user/repo.git → repo\n * - HTTPS without .git: https://github.com/user/repo → repo\n * - SSH: git@github.com:user/repo.git → repo\n * - GitLab/others: https://gitlab.com/org/project.git → project\n *\n * @param repoUrl - Git repository URL (HTTPS or SSH format)\n * @returns Repository name extracted from URL, or 'repository' as fallback\n */\nexport function extractRepoName(repoUrl) {\n    // Try parsing as standard URL (https://, http://)\n    try {\n        const url = new URL(repoUrl);\n        const pathParts = url.pathname.split('/');\n        const lastPart = pathParts[pathParts.length - 1];\n        if (lastPart) {\n            return lastPart.replace(/\\.git$/, '');\n        }\n    }\n    catch {\n        // Not a standard URL, try SSH format\n    }\n    // For SSH URLs (git@github.com:user/repo.git), split by : and / to get last segment\n    // Only process if the URL contains path delimiters\n    if (repoUrl.includes(':') || repoUrl.includes('/')) {\n        const segments = repoUrl.split(/[:/]/).filter(Boolean);\n        const lastSegment = segments[segments.length - 1];\n        if (lastSegment) {\n            return lastSegment.replace(/\\.git$/, '');\n        }\n    }\n    return FALLBACK_REPO_NAME;\n}\n/**\n * Redact credentials from URLs for secure logging\n *\n * Replaces any credentials (username:password, tokens, etc.) embedded\n * in URLs with ****** to prevent sensitive data exposure in logs.\n * Works with URLs embedded in text (e.g., \"Error: https://token@github.com/repo.git failed\")\n *\n * @param text - String that may contain URLs with credentials\n * @returns String with credentials redacted from any URLs\n */\nexport function redactCredentials(text) {\n    // Scan for http(s):// URLs and redact any credentials found\n    let result = text;\n    let pos = 0;\n    while (pos < result.length) {\n        const httpPos = result.indexOf('http://', pos);\n        const httpsPos = result.indexOf('https://', pos);\n        let protocolPos = -1;\n        let protocolLen = 0;\n        if (httpPos === -1 && httpsPos === -1)\n            break;\n        if (httpPos !== -1 && (httpsPos === -1 || httpPos < httpsPos)) {\n            protocolPos = httpPos;\n            protocolLen = 7; // 'http://'.length\n        }\n        else {\n            protocolPos = httpsPos;\n            protocolLen = 8; // 'https://'.length\n        }\n        // Look for @ after the protocol\n        const searchStart = protocolPos + protocolLen;\n        const atPos = result.indexOf('@', searchStart);\n        // Find where the URL ends (whitespace, quotes, or structural delimiters)\n        let urlEnd = searchStart;\n        while (urlEnd < result.length) {\n            const char = result[urlEnd];\n            if (/[\\s\"'`<>,;{}[\\]]/.test(char))\n                break;\n            urlEnd++;\n        }\n        if (atPos !== -1 && atPos < urlEnd) {\n            result = `${result.substring(0, searchStart)}******${result.substring(atPos)}`;\n            pos = searchStart + 6; // Move past '******'\n        }\n        else {\n            pos = protocolPos + protocolLen;\n        }\n    }\n    return result;\n}\n/**\n * Sanitize data by redacting credentials from any strings\n * Recursively processes objects and arrays to ensure credentials are never leaked\n */\nexport function sanitizeGitData(data) {\n    // Handle primitives\n    if (typeof data === 'string') {\n        return redactCredentials(data);\n    }\n    if (data === null || data === undefined) {\n        return data;\n    }\n    // Handle arrays\n    if (Array.isArray(data)) {\n        return data.map((item) => sanitizeGitData(item));\n    }\n    // Handle objects - recursively sanitize all fields\n    if (typeof data === 'object') {\n        const result = {};\n        for (const [key, value] of Object.entries(data)) {\n            result[key] = sanitizeGitData(value);\n        }\n        return result;\n    }\n    return data;\n}\n/**\n * Logger wrapper that automatically sanitizes git credentials\n */\nexport class GitLogger {\n    baseLogger;\n    constructor(baseLogger) {\n        this.baseLogger = baseLogger;\n    }\n    sanitizeContext(context) {\n        return context\n            ? sanitizeGitData(context)\n            : context;\n    }\n    sanitizeError(error) {\n        if (!error)\n            return error;\n        // Create a new error with sanitized message and stack\n        const sanitized = new Error(redactCredentials(error.message));\n        sanitized.name = error.name;\n        if (error.stack) {\n            sanitized.stack = redactCredentials(error.stack);\n        }\n        // Preserve other enumerable properties\n        const sanitizedRecord = sanitized;\n        const errorRecord = error;\n        for (const key of Object.keys(error)) {\n            if (key !== 'message' && key !== 'stack' && key !== 'name') {\n                sanitizedRecord[key] = sanitizeGitData(errorRecord[key]);\n            }\n        }\n        return sanitized;\n    }\n    debug(message, context) {\n        this.baseLogger.debug(message, this.sanitizeContext(context));\n    }\n    info(message, context) {\n        this.baseLogger.info(message, this.sanitizeContext(context));\n    }\n    warn(message, context) {\n        this.baseLogger.warn(message, this.sanitizeContext(context));\n    }\n    error(message, error, context) {\n        this.baseLogger.error(message, this.sanitizeError(error), this.sanitizeContext(context));\n    }\n    child(context) {\n        const sanitized = sanitizeGitData(context);\n        const childLogger = this.baseLogger.child(sanitized);\n        return new GitLogger(childLogger);\n    }\n}\n", "// Execution Result Container\nexport class Execution {\n    code;\n    context;\n    /**\n     * All results from the execution\n     */\n    results = [];\n    /**\n     * Accumulated stdout and stderr\n     */\n    logs = {\n        stdout: [],\n        stderr: []\n    };\n    /**\n     * Execution error if any\n     */\n    error;\n    /**\n     * Execution count (for interpreter)\n     */\n    executionCount;\n    constructor(code, context) {\n        this.code = code;\n        this.context = context;\n    }\n    /**\n     * Convert to a plain object for serialization\n     */\n    toJSON() {\n        return {\n            code: this.code,\n            logs: this.logs,\n            error: this.error,\n            executionCount: this.executionCount,\n            results: this.results.map((result) => ({\n                text: result.text,\n                html: result.html,\n                png: result.png,\n                jpeg: result.jpeg,\n                svg: result.svg,\n                latex: result.latex,\n                markdown: result.markdown,\n                javascript: result.javascript,\n                json: result.json,\n                chart: result.chart,\n                data: result.data\n            }))\n        };\n    }\n}\n// Implementation of Result\nexport class ResultImpl {\n    raw;\n    constructor(raw) {\n        this.raw = raw;\n    }\n    get text() {\n        return this.raw.text || this.raw.data?.['text/plain'];\n    }\n    get html() {\n        return this.raw.html || this.raw.data?.['text/html'];\n    }\n    get png() {\n        return this.raw.png || this.raw.data?.['image/png'];\n    }\n    get jpeg() {\n        return this.raw.jpeg || this.raw.data?.['image/jpeg'];\n    }\n    get svg() {\n        return this.raw.svg || this.raw.data?.['image/svg+xml'];\n    }\n    get latex() {\n        return this.raw.latex || this.raw.data?.['text/latex'];\n    }\n    get markdown() {\n        return this.raw.markdown || this.raw.data?.['text/markdown'];\n    }\n    get javascript() {\n        return this.raw.javascript || this.raw.data?.['application/javascript'];\n    }\n    get json() {\n        return this.raw.json || this.raw.data?.['application/json'];\n    }\n    get chart() {\n        return this.raw.chart;\n    }\n    get data() {\n        return this.raw.data;\n    }\n    formats() {\n        const formats = [];\n        if (this.text)\n            formats.push('text');\n        if (this.html)\n            formats.push('html');\n        if (this.png)\n            formats.push('png');\n        if (this.jpeg)\n            formats.push('jpeg');\n        if (this.svg)\n            formats.push('svg');\n        if (this.latex)\n            formats.push('latex');\n        if (this.markdown)\n            formats.push('markdown');\n        if (this.javascript)\n            formats.push('javascript');\n        if (this.json)\n            formats.push('json');\n        if (this.chart)\n            formats.push('chart');\n        return formats;\n    }\n}\n", "/**\n * Logger types for Cloudflare Sandbox SDK\n *\n * Provides structured, trace-aware logging across Worker, Durable Object, and Container.\n */\n/**\n * Log levels (from most to least verbose)\n */\nexport var LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"INFO\"] = 1] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 2] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 3] = \"ERROR\";\n})(LogLevel || (LogLevel = {}));\n", "/**\n * Logger implementation\n */\nimport { LogLevel as LogLevelEnum } from './types.js';\n/**\n * ANSI color codes for terminal output\n */\nconst COLORS = {\n    reset: '\\x1b[0m',\n    debug: '\\x1b[36m', // Cyan\n    info: '\\x1b[32m', // Green\n    warn: '\\x1b[33m', // Yellow\n    error: '\\x1b[31m', // Red\n    dim: '\\x1b[2m' // Dim\n};\n/**\n * CloudflareLogger implements structured logging with support for\n * both JSON output (production) and pretty printing (development).\n */\nexport class CloudflareLogger {\n    baseContext;\n    minLevel;\n    pretty;\n    /**\n     * Create a new CloudflareLogger\n     *\n     * @param baseContext Base context included in all log entries\n     * @param minLevel Minimum log level to output (default: INFO)\n     * @param pretty Enable pretty printing for human-readable output (default: false)\n     */\n    constructor(baseContext, minLevel = LogLevelEnum.INFO, pretty = false) {\n        this.baseContext = baseContext;\n        this.minLevel = minLevel;\n        this.pretty = pretty;\n    }\n    /**\n     * Log debug-level message\n     */\n    debug(message, context) {\n        if (this.shouldLog(LogLevelEnum.DEBUG)) {\n            const logData = this.buildLogData('debug', message, context);\n            this.output(console.log, logData);\n        }\n    }\n    /**\n     * Log info-level message\n     */\n    info(message, context) {\n        if (this.shouldLog(LogLevelEnum.INFO)) {\n            const logData = this.buildLogData('info', message, context);\n            this.output(console.log, logData);\n        }\n    }\n    /**\n     * Log warning-level message\n     */\n    warn(message, context) {\n        if (this.shouldLog(LogLevelEnum.WARN)) {\n            const logData = this.buildLogData('warn', message, context);\n            this.output(console.warn, logData);\n        }\n    }\n    /**\n     * Log error-level message\n     */\n    error(message, error, context) {\n        if (this.shouldLog(LogLevelEnum.ERROR)) {\n            const logData = this.buildLogData('error', message, context, error);\n            this.output(console.error, logData);\n        }\n    }\n    /**\n     * Create a child logger with additional context\n     */\n    child(context) {\n        return new CloudflareLogger({ ...this.baseContext, ...context }, this.minLevel, this.pretty);\n    }\n    /**\n     * Check if a log level should be output\n     */\n    shouldLog(level) {\n        return level >= this.minLevel;\n    }\n    /**\n     * Build log data object\n     */\n    buildLogData(level, message, context, error) {\n        const logData = {\n            level,\n            msg: message,\n            ...this.baseContext,\n            ...context,\n            timestamp: new Date().toISOString()\n        };\n        // Add error details if provided\n        if (error) {\n            logData.error = {\n                message: error.message,\n                stack: error.stack,\n                name: error.name\n            };\n        }\n        return logData;\n    }\n    /**\n     * Output log data to console (pretty or JSON)\n     */\n    output(consoleFn, data) {\n        if (this.pretty) {\n            this.outputPretty(consoleFn, data);\n        }\n        else {\n            this.outputJson(consoleFn, data);\n        }\n    }\n    /**\n     * Output as JSON (production)\n     */\n    outputJson(consoleFn, data) {\n        consoleFn(JSON.stringify(data));\n    }\n    /**\n     * Output as pretty-printed, colored text (development)\n     *\n     * Format: LEVEL [component] message (trace: tr_...) {context}\n     * Example: INFO [sandbox-do] Command started (trace: tr_7f3a9b2c) {commandId: \"cmd-123\"}\n     */\n    outputPretty(consoleFn, data) {\n        const { level, msg, timestamp, traceId, component, sandboxId, sessionId, processId, commandId, operation, duration, error, ...rest } = data;\n        // Build the main log line\n        const levelStr = String(level || 'INFO').toUpperCase();\n        const levelColor = this.getLevelColor(levelStr);\n        const componentBadge = component ? `[${component}]` : '';\n        const traceIdShort = traceId ? String(traceId).substring(0, 12) : '';\n        // Start with level and component\n        let logLine = `${levelColor}${levelStr.padEnd(5)}${COLORS.reset} ${componentBadge} ${msg}`;\n        // Add trace ID if present\n        if (traceIdShort) {\n            logLine += ` ${COLORS.dim}(trace: ${traceIdShort})${COLORS.reset}`;\n        }\n        // Collect important context fields\n        const contextFields = [];\n        if (operation)\n            contextFields.push(`operation: ${operation}`);\n        if (commandId)\n            contextFields.push(`commandId: ${String(commandId).substring(0, 12)}`);\n        if (sandboxId)\n            contextFields.push(`sandboxId: ${sandboxId}`);\n        if (sessionId)\n            contextFields.push(`sessionId: ${String(sessionId).substring(0, 12)}`);\n        if (processId)\n            contextFields.push(`processId: ${processId}`);\n        if (duration !== undefined)\n            contextFields.push(`duration: ${duration}ms`);\n        // Add important context inline\n        if (contextFields.length > 0) {\n            logLine += ` ${COLORS.dim}{${contextFields.join(', ')}}${COLORS.reset}`;\n        }\n        // Output main log line\n        consoleFn(logLine);\n        // Output error details on separate lines if present\n        if (error && typeof error === 'object') {\n            const errorObj = error;\n            if (errorObj.message) {\n                consoleFn(`  ${COLORS.error}Error: ${errorObj.message}${COLORS.reset}`);\n            }\n            if (errorObj.stack) {\n                consoleFn(`  ${COLORS.dim}${errorObj.stack}${COLORS.reset}`);\n            }\n        }\n        // Output additional context if present\n        if (Object.keys(rest).length > 0) {\n            consoleFn(`  ${COLORS.dim}${JSON.stringify(rest, null, 2)}${COLORS.reset}`);\n        }\n    }\n    /**\n     * Get ANSI color code for log level\n     */\n    getLevelColor(level) {\n        const levelLower = level.toLowerCase();\n        switch (levelLower) {\n            case 'debug':\n                return COLORS.debug;\n            case 'info':\n                return COLORS.info;\n            case 'warn':\n                return COLORS.warn;\n            case 'error':\n                return COLORS.error;\n            default:\n                return COLORS.reset;\n        }\n    }\n}\n", "/**\n * Trace context utilities for request correlation\n *\n * Trace IDs enable correlating logs across distributed components:\n * Worker → Durable Object → Container → back\n *\n * The trace ID is propagated via the X-Trace-Id HTTP header.\n */\n/**\n * Utility for managing trace context across distributed components\n */\n// biome-ignore lint/complexity/noStaticOnlyClass: Keep as class for namespace grouping and discoverability\nexport class TraceContext {\n    /**\n     * HTTP header name for trace ID propagation\n     */\n    static TRACE_HEADER = 'X-Trace-Id';\n    /**\n     * Generate a new trace ID\n     *\n     * Format: \"tr_\" + 16 random hex characters\n     * Example: \"tr_7f3a9b2c4e5d6f1a\"\n     *\n     * @returns Newly generated trace ID\n     */\n    static generate() {\n        // Use crypto.randomUUID() for randomness, extract 16 hex chars\n        const randomHex = crypto.randomUUID().replace(/-/g, '').substring(0, 16);\n        return `tr_${randomHex}`;\n    }\n    /**\n     * Extract trace ID from HTTP request headers\n     *\n     * @param headers Request headers\n     * @returns Trace ID if present, null otherwise\n     */\n    static fromHeaders(headers) {\n        return headers.get(TraceContext.TRACE_HEADER);\n    }\n    /**\n     * Create headers object with trace ID for outgoing requests\n     *\n     * @param traceId Trace ID to include\n     * @returns Headers object with X-Trace-Id set\n     */\n    static toHeaders(traceId) {\n        return { [TraceContext.TRACE_HEADER]: traceId };\n    }\n    /**\n     * Get the header name used for trace ID propagation\n     *\n     * @returns Header name (\"X-Trace-Id\")\n     */\n    static getHeaderName() {\n        return TraceContext.TRACE_HEADER;\n    }\n}\n", "/**\n * Logger module\n *\n * Provides structured, trace-aware logging with:\n * - Explicit logger passing via constructor injection\n * - Pretty printing for local development\n * - JSON output for production\n * - Environment auto-detection\n * - Log level configuration\n *\n * Usage:\n *\n * ```typescript\n * // Create a logger at entry point\n * const logger = createLogger({ component: 'sandbox-do', traceId: 'tr_abc123' });\n *\n * // Pass to classes via constructor\n * const service = new MyService(logger);\n *\n * // Create child loggers for additional context\n * const execLogger = logger.child({ operation: 'exec', commandId: 'cmd-456' });\n * execLogger.info('Operation started');\n * ```\n */\nimport { CloudflareLogger } from './logger.js';\nimport { TraceContext } from './trace-context.js';\nimport { LogLevel as LogLevelEnum } from './types.js';\nexport { CloudflareLogger } from './logger.js';\nexport { TraceContext } from './trace-context.js';\nexport { LogLevel as LogLevelEnum } from './types.js';\n/**\n * Create a no-op logger for testing\n *\n * Returns a logger that implements the Logger interface but does nothing.\n * Useful for tests that don't need actual logging output.\n *\n * @returns No-op logger instance\n *\n * @example\n * ```typescript\n * // In tests\n * const client = new HttpClient({\n *   baseUrl: 'http://test.com',\n *   logger: createNoOpLogger() // Optional - tests can enable real logging if needed\n * });\n * ```\n */\nexport function createNoOpLogger() {\n    return {\n        debug: () => { },\n        info: () => { },\n        warn: () => { },\n        error: () => { },\n        child: () => createNoOpLogger()\n    };\n}\n/**\n * Create a new logger instance\n *\n * @param context Base context for the logger. Must include 'component'.\n *                TraceId will be auto-generated if not provided.\n * @returns New logger instance\n *\n * @example\n * ```typescript\n * // In Durable Object\n * const logger = createLogger({\n *   component: 'sandbox-do',\n *   traceId: TraceContext.fromHeaders(request.headers) || TraceContext.generate(),\n *   sandboxId: this.id\n * });\n *\n * // In Container\n * const logger = createLogger({\n *   component: 'container',\n *   traceId: TraceContext.fromHeaders(request.headers)!,\n *   sessionId: this.id\n * });\n * ```\n */\nexport function createLogger(context) {\n    const minLevel = getLogLevelFromEnv();\n    const pretty = isPrettyPrintEnabled();\n    const baseContext = {\n        ...context,\n        traceId: context.traceId || TraceContext.generate(),\n        component: context.component\n    };\n    return new CloudflareLogger(baseContext, minLevel, pretty);\n}\n/**\n * Get log level from environment variable\n *\n * Checks SANDBOX_LOG_LEVEL env var, falls back to default based on environment.\n * Default: 'debug' for development, 'info' for production\n */\nfunction getLogLevelFromEnv() {\n    const envLevel = getEnvVar('SANDBOX_LOG_LEVEL') || 'info';\n    switch (envLevel.toLowerCase()) {\n        case 'debug':\n            return LogLevelEnum.DEBUG;\n        case 'info':\n            return LogLevelEnum.INFO;\n        case 'warn':\n            return LogLevelEnum.WARN;\n        case 'error':\n            return LogLevelEnum.ERROR;\n        default:\n            // Invalid level, fall back to info\n            return LogLevelEnum.INFO;\n    }\n}\n/**\n * Check if pretty printing should be enabled\n *\n * Checks SANDBOX_LOG_FORMAT env var, falls back to auto-detection:\n * - Local development: pretty (colored, human-readable)\n * - Production: json (structured)\n */\nfunction isPrettyPrintEnabled() {\n    // Check explicit SANDBOX_LOG_FORMAT env var\n    const format = getEnvVar('SANDBOX_LOG_FORMAT');\n    if (format) {\n        return format.toLowerCase() === 'pretty';\n    }\n    return false;\n}\n/**\n * Get environment variable value\n *\n * Supports both Node.js (process.env) and Bun (Bun.env)\n */\nfunction getEnvVar(name) {\n    // Try process.env first (Node.js / Bun)\n    if (typeof process !== 'undefined' && process.env) {\n        return process.env[name];\n    }\n    // Try Bun.env (Bun runtime)\n    if (typeof Bun !== 'undefined') {\n        const bunEnv = Bun.env;\n        if (bunEnv) {\n            return bunEnv[name];\n        }\n    }\n    return undefined;\n}\n", "/**\n * Escapes a string for safe use in shell commands using POSIX single-quote escaping.\n * Prevents command injection by wrapping the string in single quotes and escaping\n * any single quotes within the string.\n */\nexport function shellEscape(str) {\n    return `'${str.replace(/'/g, \"'\\\\''\")}'`;\n}\n", "/**\n * Check if a process status indicates the process has terminated\n */\nexport function isTerminalStatus(status) {\n    return (status === 'completed' ||\n        status === 'failed' ||\n        status === 'killed' ||\n        status === 'error');\n}\n// Type guards for runtime validation\nexport function isExecResult(value) {\n    return (value &&\n        typeof value.success === 'boolean' &&\n        typeof value.exitCode === 'number' &&\n        typeof value.stdout === 'string' &&\n        typeof value.stderr === 'string');\n}\nexport function isProcess(value) {\n    return (value &&\n        typeof value.id === 'string' &&\n        typeof value.command === 'string' &&\n        typeof value.status === 'string');\n}\nexport function isProcessStatus(value) {\n    return [\n        'starting',\n        'running',\n        'completed',\n        'failed',\n        'killed',\n        'error'\n    ].includes(value);\n}\n// Re-export interpreter types for convenience\nexport { Execution, ResultImpl } from './interpreter-types';\n", "/**\n * WebSocket transport protocol types\n *\n * Enables multiplexing HTTP-like requests over a single WebSocket connection.\n * This reduces sub-request count when running inside Workers/Durable Objects.\n *\n * Protocol:\n * - Client sends WSRequest messages\n * - Server responds with WSResponse messages (matched by id)\n * - For streaming endpoints, server sends multiple WSStreamChunk messages\n *   followed by a final WSResponse\n */\n/**\n * Type guard for WSRequest\n *\n * Note: Only validates the discriminator field (type === 'request').\n * Does not validate other required fields (id, method, path).\n * Use for routing messages; trust TypeScript for field validation.\n */\nexport function isWSRequest(msg) {\n    return (typeof msg === 'object' &&\n        msg !== null &&\n        'type' in msg &&\n        msg.type === 'request');\n}\n/**\n * Type guard for WSResponse\n *\n * Note: Only validates the discriminator field (type === 'response').\n */\nexport function isWSResponse(msg) {\n    return (typeof msg === 'object' &&\n        msg !== null &&\n        'type' in msg &&\n        msg.type === 'response');\n}\n/**\n * Type guard for WSStreamChunk\n *\n * Note: Only validates the discriminator field (type === 'stream').\n */\nexport function isWSStreamChunk(msg) {\n    return (typeof msg === 'object' &&\n        msg !== null &&\n        'type' in msg &&\n        msg.type === 'stream');\n}\n/**\n * Type guard for WSError\n *\n * Note: Only validates the discriminator field (type === 'error').\n */\nexport function isWSError(msg) {\n    return (typeof msg === 'object' &&\n        msg !== null &&\n        'type' in msg &&\n        msg.type === 'error');\n}\n/**\n * Generate a unique request ID\n */\nexport function generateRequestId() {\n    return `ws_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;\n}\n", "/**\n * Centralized error code registry\n * Each code maps to a specific error type with consistent semantics\n */\nexport const ErrorCode = {\n    // File System Errors (404)\n    FILE_NOT_FOUND: 'FILE_NOT_FOUND',\n    // Permission Errors (403)\n    PERMISSION_DENIED: 'PERMISSION_DENIED',\n    // File System Errors (409)\n    FILE_EXISTS: 'FILE_EXISTS',\n    // File System Errors (400)\n    IS_DIRECTORY: 'IS_DIRECTORY',\n    NOT_DIRECTORY: 'NOT_DIRECTORY',\n    // File System Errors (500)\n    NO_SPACE: 'NO_SPACE',\n    TOO_MANY_FILES: 'TOO_MANY_FILES',\n    RESOURCE_BUSY: 'RESOURCE_BUSY',\n    READ_ONLY: 'READ_ONLY',\n    NAME_TOO_LONG: 'NAME_TOO_LONG',\n    TOO_MANY_LINKS: 'TOO_MANY_LINKS',\n    FILESYSTEM_ERROR: 'FILESYSTEM_ERROR',\n    // Command Errors (404)\n    COMMAND_NOT_FOUND: 'COMMAND_NOT_FOUND',\n    // Command Errors (403/400)\n    COMMAND_PERMISSION_DENIED: 'COMMAND_PERMISSION_DENIED',\n    INVALID_COMMAND: 'INVALID_COMMAND',\n    // Command Errors (500)\n    COMMAND_EXECUTION_ERROR: 'COMMAND_EXECUTION_ERROR',\n    STREAM_START_ERROR: 'STREAM_START_ERROR',\n    // Process Errors (404)\n    PROCESS_NOT_FOUND: 'PROCESS_NOT_FOUND',\n    // Process Errors (403/500)\n    PROCESS_PERMISSION_DENIED: 'PROCESS_PERMISSION_DENIED',\n    PROCESS_ERROR: 'PROCESS_ERROR',\n    // Session Errors (409)\n    SESSION_ALREADY_EXISTS: 'SESSION_ALREADY_EXISTS',\n    // Port Errors (409)\n    PORT_ALREADY_EXPOSED: 'PORT_ALREADY_EXPOSED',\n    PORT_IN_USE: 'PORT_IN_USE',\n    // Port Errors (404)\n    PORT_NOT_EXPOSED: 'PORT_NOT_EXPOSED',\n    // Port Errors (400)\n    INVALID_PORT_NUMBER: 'INVALID_PORT_NUMBER',\n    INVALID_PORT: 'INVALID_PORT',\n    // Port Errors (502/500)\n    SERVICE_NOT_RESPONDING: 'SERVICE_NOT_RESPONDING',\n    PORT_OPERATION_ERROR: 'PORT_OPERATION_ERROR',\n    // Port Errors (400)\n    CUSTOM_DOMAIN_REQUIRED: 'CUSTOM_DOMAIN_REQUIRED',\n    // Git Errors (404)\n    GIT_REPOSITORY_NOT_FOUND: 'GIT_REPOSITORY_NOT_FOUND',\n    GIT_BRANCH_NOT_FOUND: 'GIT_BRANCH_NOT_FOUND',\n    // Git Errors (401)\n    GIT_AUTH_FAILED: 'GIT_AUTH_FAILED',\n    // Git Errors (502)\n    GIT_NETWORK_ERROR: 'GIT_NETWORK_ERROR',\n    // Git Errors (400)\n    INVALID_GIT_URL: 'INVALID_GIT_URL',\n    // Git Errors (500)\n    GIT_CLONE_FAILED: 'GIT_CLONE_FAILED',\n    GIT_CHECKOUT_FAILED: 'GIT_CHECKOUT_FAILED',\n    GIT_OPERATION_FAILED: 'GIT_OPERATION_FAILED',\n    // Bucket mounting errors\n    BUCKET_MOUNT_ERROR: 'BUCKET_MOUNT_ERROR',\n    S3FS_MOUNT_ERROR: 'S3FS_MOUNT_ERROR',\n    MISSING_CREDENTIALS: 'MISSING_CREDENTIALS',\n    INVALID_MOUNT_CONFIG: 'INVALID_MOUNT_CONFIG',\n    // Code Interpreter Errors (503)\n    INTERPRETER_NOT_READY: 'INTERPRETER_NOT_READY',\n    // Code Interpreter Errors (404)\n    CONTEXT_NOT_FOUND: 'CONTEXT_NOT_FOUND',\n    // Code Interpreter Errors (500)\n    CODE_EXECUTION_ERROR: 'CODE_EXECUTION_ERROR',\n    // Code Interpreter Errors (501) - Feature not available in image variant\n    PYTHON_NOT_AVAILABLE: 'PYTHON_NOT_AVAILABLE',\n    JAVASCRIPT_NOT_AVAILABLE: 'JAVASCRIPT_NOT_AVAILABLE',\n    // OpenCode Errors (503)\n    OPENCODE_STARTUP_FAILED: 'OPENCODE_STARTUP_FAILED',\n    // Process Readiness Errors (408/500)\n    PROCESS_READY_TIMEOUT: 'PROCESS_READY_TIMEOUT',\n    PROCESS_EXITED_BEFORE_READY: 'PROCESS_EXITED_BEFORE_READY',\n    // Validation Errors (400)\n    VALIDATION_FAILED: 'VALIDATION_FAILED',\n    // Generic Errors (400/500)\n    INVALID_JSON_RESPONSE: 'INVALID_JSON_RESPONSE',\n    UNKNOWN_ERROR: 'UNKNOWN_ERROR',\n    INTERNAL_ERROR: 'INTERNAL_ERROR'\n};\n", "import { ErrorCode } from './codes';\n/**\n * Maps error codes to HTTP status codes\n * Centralized mapping ensures consistency across SDK\n */\nexport const ERROR_STATUS_MAP = {\n    // 404 Not Found\n    [ErrorCode.FILE_NOT_FOUND]: 404,\n    [ErrorCode.COMMAND_NOT_FOUND]: 404,\n    [ErrorCode.PROCESS_NOT_FOUND]: 404,\n    [ErrorCode.PORT_NOT_EXPOSED]: 404,\n    [ErrorCode.GIT_REPOSITORY_NOT_FOUND]: 404,\n    [ErrorCode.GIT_BRANCH_NOT_FOUND]: 404,\n    [ErrorCode.CONTEXT_NOT_FOUND]: 404,\n    // 400 Bad Request\n    [ErrorCode.IS_DIRECTORY]: 400,\n    [ErrorCode.NOT_DIRECTORY]: 400,\n    [ErrorCode.INVALID_COMMAND]: 400,\n    [ErrorCode.INVALID_PORT_NUMBER]: 400,\n    [ErrorCode.INVALID_PORT]: 400,\n    [ErrorCode.INVALID_GIT_URL]: 400,\n    [ErrorCode.CUSTOM_DOMAIN_REQUIRED]: 400,\n    [ErrorCode.INVALID_JSON_RESPONSE]: 400,\n    [ErrorCode.NAME_TOO_LONG]: 400,\n    [ErrorCode.VALIDATION_FAILED]: 400,\n    [ErrorCode.MISSING_CREDENTIALS]: 400,\n    [ErrorCode.INVALID_MOUNT_CONFIG]: 400,\n    // 401 Unauthorized\n    [ErrorCode.GIT_AUTH_FAILED]: 401,\n    // 403 Forbidden\n    [ErrorCode.PERMISSION_DENIED]: 403,\n    [ErrorCode.COMMAND_PERMISSION_DENIED]: 403,\n    [ErrorCode.PROCESS_PERMISSION_DENIED]: 403,\n    [ErrorCode.READ_ONLY]: 403,\n    // 409 Conflict\n    [ErrorCode.FILE_EXISTS]: 409,\n    [ErrorCode.PORT_ALREADY_EXPOSED]: 409,\n    [ErrorCode.PORT_IN_USE]: 409,\n    [ErrorCode.RESOURCE_BUSY]: 409,\n    [ErrorCode.SESSION_ALREADY_EXISTS]: 409,\n    // 502 Bad Gateway\n    [ErrorCode.SERVICE_NOT_RESPONDING]: 502,\n    [ErrorCode.GIT_NETWORK_ERROR]: 502,\n    // 501 Not Implemented (feature not available in image variant)\n    [ErrorCode.PYTHON_NOT_AVAILABLE]: 501,\n    [ErrorCode.JAVASCRIPT_NOT_AVAILABLE]: 501,\n    // 503 Service Unavailable\n    [ErrorCode.INTERPRETER_NOT_READY]: 503,\n    [ErrorCode.OPENCODE_STARTUP_FAILED]: 503,\n    // 408 Request Timeout\n    [ErrorCode.PROCESS_READY_TIMEOUT]: 408,\n    // 500 Internal Server Error\n    [ErrorCode.PROCESS_EXITED_BEFORE_READY]: 500,\n    [ErrorCode.NO_SPACE]: 500,\n    [ErrorCode.TOO_MANY_FILES]: 500,\n    [ErrorCode.TOO_MANY_LINKS]: 500,\n    [ErrorCode.FILESYSTEM_ERROR]: 500,\n    [ErrorCode.COMMAND_EXECUTION_ERROR]: 500,\n    [ErrorCode.STREAM_START_ERROR]: 500,\n    [ErrorCode.PROCESS_ERROR]: 500,\n    [ErrorCode.PORT_OPERATION_ERROR]: 500,\n    [ErrorCode.GIT_CLONE_FAILED]: 500,\n    [ErrorCode.GIT_CHECKOUT_FAILED]: 500,\n    [ErrorCode.GIT_OPERATION_FAILED]: 500,\n    [ErrorCode.CODE_EXECUTION_ERROR]: 500,\n    [ErrorCode.BUCKET_MOUNT_ERROR]: 500,\n    [ErrorCode.S3FS_MOUNT_ERROR]: 500,\n    [ErrorCode.UNKNOWN_ERROR]: 500,\n    [ErrorCode.INTERNAL_ERROR]: 500\n};\n/**\n * Get HTTP status code for an error code\n * Falls back to 500 for unknown errors\n */\nexport function getHttpStatus(code) {\n    return ERROR_STATUS_MAP[code] || 500;\n}\n", null, null, "/**\n * Type-safe error classes that wrap ErrorResponse from container\n *\n * All error classes extend SandboxError<TContext> which wraps the full ErrorResponse\n * and provides type-safe accessors for error properties.\n */\n\nimport type {\n  CodeExecutionContext,\n  CommandErrorContext,\n  CommandNotFoundContext,\n  ContextNotFoundContext,\n  ErrorResponse,\n  FileExistsContext,\n  FileNotFoundContext,\n  FileSystemContext,\n  GitAuthFailedContext,\n  GitBranchNotFoundContext,\n  GitErrorContext,\n  GitRepositoryNotFoundContext,\n  InternalErrorContext,\n  InterpreterNotReadyContext,\n  InvalidPortContext,\n  PortAlreadyExposedContext,\n  PortErrorContext,\n  PortNotExposedContext,\n  ProcessErrorContext,\n  ProcessExitedBeforeReadyContext,\n  ProcessNotFoundContext,\n  ProcessReadyTimeoutContext,\n  SessionAlreadyExistsContext,\n  ValidationFailedContext\n} from '@repo/shared/errors';\n\n/**\n * Base SDK error that wraps ErrorResponse\n * Preserves all error information from container\n */\nexport class SandboxError<TContext = Record<string, unknown>> extends Error {\n  constructor(public readonly errorResponse: ErrorResponse<TContext>) {\n    super(errorResponse.message);\n    this.name = 'SandboxError';\n  }\n\n  // Convenience accessors\n  get code() {\n    return this.errorResponse.code;\n  }\n  get context() {\n    return this.errorResponse.context;\n  }\n  get httpStatus() {\n    return this.errorResponse.httpStatus;\n  }\n  get operation() {\n    return this.errorResponse.operation;\n  }\n  get suggestion() {\n    return this.errorResponse.suggestion;\n  }\n  get timestamp() {\n    return this.errorResponse.timestamp;\n  }\n  get documentation() {\n    return this.errorResponse.documentation;\n  }\n\n  // Custom serialization for logging\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      context: this.context,\n      httpStatus: this.httpStatus,\n      operation: this.operation,\n      suggestion: this.suggestion,\n      timestamp: this.timestamp,\n      documentation: this.documentation,\n      stack: this.stack\n    };\n  }\n}\n\n// ============================================================================\n// File System Errors\n// ============================================================================\n\n/**\n * Error thrown when a file or directory is not found\n */\nexport class FileNotFoundError extends SandboxError<FileNotFoundContext> {\n  constructor(errorResponse: ErrorResponse<FileNotFoundContext>) {\n    super(errorResponse);\n    this.name = 'FileNotFoundError';\n  }\n\n  // Type-safe accessors\n  get path() {\n    return this.context.path;\n  }\n}\n\n/**\n * Error thrown when a file already exists\n */\nexport class FileExistsError extends SandboxError<FileExistsContext> {\n  constructor(errorResponse: ErrorResponse<FileExistsContext>) {\n    super(errorResponse);\n    this.name = 'FileExistsError';\n  }\n\n  // Type-safe accessor\n  get path() {\n    return this.context.path;\n  }\n}\n\n/**\n * Generic file system error (permissions, disk full, etc.)\n */\nexport class FileSystemError extends SandboxError<FileSystemContext> {\n  constructor(errorResponse: ErrorResponse<FileSystemContext>) {\n    super(errorResponse);\n    this.name = 'FileSystemError';\n  }\n\n  // Type-safe accessors\n  get path() {\n    return this.context.path;\n  }\n  get stderr() {\n    return this.context.stderr;\n  }\n  get exitCode() {\n    return this.context.exitCode;\n  }\n}\n\n/**\n * Error thrown when permission is denied\n */\nexport class PermissionDeniedError extends SandboxError<FileSystemContext> {\n  constructor(errorResponse: ErrorResponse<FileSystemContext>) {\n    super(errorResponse);\n    this.name = 'PermissionDeniedError';\n  }\n\n  get path() {\n    return this.context.path;\n  }\n}\n\n// ============================================================================\n// Command Errors\n// ============================================================================\n\n/**\n * Error thrown when a command is not found\n */\nexport class CommandNotFoundError extends SandboxError<CommandNotFoundContext> {\n  constructor(errorResponse: ErrorResponse<CommandNotFoundContext>) {\n    super(errorResponse);\n    this.name = 'CommandNotFoundError';\n  }\n\n  // Type-safe accessor\n  get command() {\n    return this.context.command;\n  }\n}\n\n/**\n * Generic command execution error\n */\nexport class CommandError extends SandboxError<CommandErrorContext> {\n  constructor(errorResponse: ErrorResponse<CommandErrorContext>) {\n    super(errorResponse);\n    this.name = 'CommandError';\n  }\n\n  // Type-safe accessors\n  get command() {\n    return this.context.command;\n  }\n  get exitCode() {\n    return this.context.exitCode;\n  }\n  get stdout() {\n    return this.context.stdout;\n  }\n  get stderr() {\n    return this.context.stderr;\n  }\n}\n\n// ============================================================================\n// Process Errors\n// ============================================================================\n\n/**\n * Error thrown when a process is not found\n */\nexport class ProcessNotFoundError extends SandboxError<ProcessNotFoundContext> {\n  constructor(errorResponse: ErrorResponse<ProcessNotFoundContext>) {\n    super(errorResponse);\n    this.name = 'ProcessNotFoundError';\n  }\n\n  // Type-safe accessor\n  get processId() {\n    return this.context.processId;\n  }\n}\n\n/**\n * Generic process error\n */\nexport class ProcessError extends SandboxError<ProcessErrorContext> {\n  constructor(errorResponse: ErrorResponse<ProcessErrorContext>) {\n    super(errorResponse);\n    this.name = 'ProcessError';\n  }\n\n  // Type-safe accessors\n  get processId() {\n    return this.context.processId;\n  }\n  get pid() {\n    return this.context.pid;\n  }\n  get exitCode() {\n    return this.context.exitCode;\n  }\n  get stderr() {\n    return this.context.stderr;\n  }\n}\n\n// ============================================================================\n// Session Errors\n// ============================================================================\n\n/**\n * Error thrown when a session already exists\n */\nexport class SessionAlreadyExistsError extends SandboxError<SessionAlreadyExistsContext> {\n  constructor(errorResponse: ErrorResponse<SessionAlreadyExistsContext>) {\n    super(errorResponse);\n    this.name = 'SessionAlreadyExistsError';\n  }\n\n  // Type-safe accessors\n  get sessionId() {\n    return this.context.sessionId;\n  }\n}\n\n// ============================================================================\n// Port Errors\n// ============================================================================\n\n/**\n * Error thrown when a port is already exposed\n */\nexport class PortAlreadyExposedError extends SandboxError<PortAlreadyExposedContext> {\n  constructor(errorResponse: ErrorResponse<PortAlreadyExposedContext>) {\n    super(errorResponse);\n    this.name = 'PortAlreadyExposedError';\n  }\n\n  // Type-safe accessors\n  get port() {\n    return this.context.port;\n  }\n  get portName() {\n    return this.context.portName;\n  }\n}\n\n/**\n * Error thrown when a port is not exposed\n */\nexport class PortNotExposedError extends SandboxError<PortNotExposedContext> {\n  constructor(errorResponse: ErrorResponse<PortNotExposedContext>) {\n    super(errorResponse);\n    this.name = 'PortNotExposedError';\n  }\n\n  // Type-safe accessor\n  get port() {\n    return this.context.port;\n  }\n}\n\n/**\n * Error thrown when a port number is invalid\n */\nexport class InvalidPortError extends SandboxError<InvalidPortContext> {\n  constructor(errorResponse: ErrorResponse<InvalidPortContext>) {\n    super(errorResponse);\n    this.name = 'InvalidPortError';\n  }\n\n  // Type-safe accessors\n  get port() {\n    return this.context.port;\n  }\n  get reason() {\n    return this.context.reason;\n  }\n}\n\n/**\n * Error thrown when a service on a port is not responding\n */\nexport class ServiceNotRespondingError extends SandboxError<PortErrorContext> {\n  constructor(errorResponse: ErrorResponse<PortErrorContext>) {\n    super(errorResponse);\n    this.name = 'ServiceNotRespondingError';\n  }\n\n  // Type-safe accessors\n  get port() {\n    return this.context.port;\n  }\n  get portName() {\n    return this.context.portName;\n  }\n}\n\n/**\n * Error thrown when a port is already in use\n */\nexport class PortInUseError extends SandboxError<PortErrorContext> {\n  constructor(errorResponse: ErrorResponse<PortErrorContext>) {\n    super(errorResponse);\n    this.name = 'PortInUseError';\n  }\n\n  // Type-safe accessor\n  get port() {\n    return this.context.port;\n  }\n}\n\n/**\n * Generic port operation error\n */\nexport class PortError extends SandboxError<PortErrorContext> {\n  constructor(errorResponse: ErrorResponse<PortErrorContext>) {\n    super(errorResponse);\n    this.name = 'PortError';\n  }\n\n  // Type-safe accessors\n  get port() {\n    return this.context.port;\n  }\n  get portName() {\n    return this.context.portName;\n  }\n  get stderr() {\n    return this.context.stderr;\n  }\n}\n\n/**\n * Error thrown when port exposure requires a custom domain\n */\nexport class CustomDomainRequiredError extends SandboxError<InternalErrorContext> {\n  constructor(errorResponse: ErrorResponse<InternalErrorContext>) {\n    super(errorResponse);\n    this.name = 'CustomDomainRequiredError';\n  }\n}\n\n// ============================================================================\n// Git Errors\n// ============================================================================\n\n/**\n * Error thrown when a git repository is not found\n */\nexport class GitRepositoryNotFoundError extends SandboxError<GitRepositoryNotFoundContext> {\n  constructor(errorResponse: ErrorResponse<GitRepositoryNotFoundContext>) {\n    super(errorResponse);\n    this.name = 'GitRepositoryNotFoundError';\n  }\n\n  // Type-safe accessor\n  get repository() {\n    return this.context.repository;\n  }\n}\n\n/**\n * Error thrown when git authentication fails\n */\nexport class GitAuthenticationError extends SandboxError<GitAuthFailedContext> {\n  constructor(errorResponse: ErrorResponse<GitAuthFailedContext>) {\n    super(errorResponse);\n    this.name = 'GitAuthenticationError';\n  }\n\n  // Type-safe accessor\n  get repository() {\n    return this.context.repository;\n  }\n}\n\n/**\n * Error thrown when a git branch is not found\n */\nexport class GitBranchNotFoundError extends SandboxError<GitBranchNotFoundContext> {\n  constructor(errorResponse: ErrorResponse<GitBranchNotFoundContext>) {\n    super(errorResponse);\n    this.name = 'GitBranchNotFoundError';\n  }\n\n  // Type-safe accessors\n  get branch() {\n    return this.context.branch;\n  }\n  get repository() {\n    return this.context.repository;\n  }\n}\n\n/**\n * Error thrown when a git network operation fails\n */\nexport class GitNetworkError extends SandboxError<GitErrorContext> {\n  constructor(errorResponse: ErrorResponse<GitErrorContext>) {\n    super(errorResponse);\n    this.name = 'GitNetworkError';\n  }\n\n  // Type-safe accessors\n  get repository() {\n    return this.context.repository;\n  }\n  get branch() {\n    return this.context.branch;\n  }\n  get targetDir() {\n    return this.context.targetDir;\n  }\n}\n\n/**\n * Error thrown when git clone fails\n */\nexport class GitCloneError extends SandboxError<GitErrorContext> {\n  constructor(errorResponse: ErrorResponse<GitErrorContext>) {\n    super(errorResponse);\n    this.name = 'GitCloneError';\n  }\n\n  // Type-safe accessors\n  get repository() {\n    return this.context.repository;\n  }\n  get targetDir() {\n    return this.context.targetDir;\n  }\n  get stderr() {\n    return this.context.stderr;\n  }\n  get exitCode() {\n    return this.context.exitCode;\n  }\n}\n\n/**\n * Error thrown when git checkout fails\n */\nexport class GitCheckoutError extends SandboxError<GitErrorContext> {\n  constructor(errorResponse: ErrorResponse<GitErrorContext>) {\n    super(errorResponse);\n    this.name = 'GitCheckoutError';\n  }\n\n  // Type-safe accessors\n  get branch() {\n    return this.context.branch;\n  }\n  get repository() {\n    return this.context.repository;\n  }\n  get stderr() {\n    return this.context.stderr;\n  }\n}\n\n/**\n * Error thrown when a git URL is invalid\n */\nexport class InvalidGitUrlError extends SandboxError<ValidationFailedContext> {\n  constructor(errorResponse: ErrorResponse<ValidationFailedContext>) {\n    super(errorResponse);\n    this.name = 'InvalidGitUrlError';\n  }\n\n  // Type-safe accessor\n  get validationErrors() {\n    return this.context.validationErrors;\n  }\n}\n\n/**\n * Generic git operation error\n */\nexport class GitError extends SandboxError<GitErrorContext> {\n  constructor(errorResponse: ErrorResponse<GitErrorContext>) {\n    super(errorResponse);\n    this.name = 'GitError';\n  }\n\n  // Type-safe accessors\n  get repository() {\n    return this.context.repository;\n  }\n  get branch() {\n    return this.context.branch;\n  }\n  get targetDir() {\n    return this.context.targetDir;\n  }\n  get stderr() {\n    return this.context.stderr;\n  }\n  get exitCode() {\n    return this.context.exitCode;\n  }\n}\n\n// ============================================================================\n// Code Interpreter Errors\n// ============================================================================\n\n/**\n * Error thrown when interpreter is not ready\n */\nexport class InterpreterNotReadyError extends SandboxError<InterpreterNotReadyContext> {\n  constructor(errorResponse: ErrorResponse<InterpreterNotReadyContext>) {\n    super(errorResponse);\n    this.name = 'InterpreterNotReadyError';\n  }\n\n  // Type-safe accessors\n  get retryAfter() {\n    return this.context.retryAfter;\n  }\n  get progress() {\n    return this.context.progress;\n  }\n}\n\n/**\n * Error thrown when a context is not found\n */\nexport class ContextNotFoundError extends SandboxError<ContextNotFoundContext> {\n  constructor(errorResponse: ErrorResponse<ContextNotFoundContext>) {\n    super(errorResponse);\n    this.name = 'ContextNotFoundError';\n  }\n\n  // Type-safe accessor\n  get contextId() {\n    return this.context.contextId;\n  }\n}\n\n/**\n * Error thrown when code execution fails\n */\nexport class CodeExecutionError extends SandboxError<CodeExecutionContext> {\n  constructor(errorResponse: ErrorResponse<CodeExecutionContext>) {\n    super(errorResponse);\n    this.name = 'CodeExecutionError';\n  }\n\n  // Type-safe accessors\n  get contextId() {\n    return this.context.contextId;\n  }\n  get ename() {\n    return this.context.ename;\n  }\n  get evalue() {\n    return this.context.evalue;\n  }\n  get traceback() {\n    return this.context.traceback;\n  }\n}\n\n// ============================================================================\n// Validation Errors\n// ============================================================================\n\n/**\n * Error thrown when validation fails\n */\nexport class ValidationFailedError extends SandboxError<ValidationFailedContext> {\n  constructor(errorResponse: ErrorResponse<ValidationFailedContext>) {\n    super(errorResponse);\n    this.name = 'ValidationFailedError';\n  }\n\n  // Type-safe accessor\n  get validationErrors() {\n    return this.context.validationErrors;\n  }\n}\n\n// ============================================================================\n// Process Readiness Errors\n// ============================================================================\n\n/**\n * Error thrown when a process does not become ready within the timeout period\n */\nexport class ProcessReadyTimeoutError extends SandboxError<ProcessReadyTimeoutContext> {\n  constructor(errorResponse: ErrorResponse<ProcessReadyTimeoutContext>) {\n    super(errorResponse);\n    this.name = 'ProcessReadyTimeoutError';\n  }\n\n  // Type-safe accessors\n  get processId() {\n    return this.context.processId;\n  }\n  get command() {\n    return this.context.command;\n  }\n  get condition() {\n    return this.context.condition;\n  }\n  get timeout() {\n    return this.context.timeout;\n  }\n}\n\n/**\n * Error thrown when a process exits before becoming ready\n */\nexport class ProcessExitedBeforeReadyError extends SandboxError<ProcessExitedBeforeReadyContext> {\n  constructor(errorResponse: ErrorResponse<ProcessExitedBeforeReadyContext>) {\n    super(errorResponse);\n    this.name = 'ProcessExitedBeforeReadyError';\n  }\n\n  // Type-safe accessors\n  get processId() {\n    return this.context.processId;\n  }\n  get command() {\n    return this.context.command;\n  }\n  get condition() {\n    return this.context.condition;\n  }\n  get exitCode() {\n    return this.context.exitCode;\n  }\n}\n", "/**\n * Error adapter that converts ErrorResponse to appropriate Error class\n *\n * Simple switch statement - we trust the container sends correct context\n * No validation overhead since we control both sides\n */\n\nimport type {\n  CodeExecutionContext,\n  CommandErrorContext,\n  CommandNotFoundContext,\n  ContextNotFoundContext,\n  ErrorResponse,\n  FileExistsContext,\n  FileNotFoundContext,\n  FileSystemContext,\n  GitAuthFailedContext,\n  GitBranchNotFoundContext,\n  GitErrorContext,\n  GitRepositoryNotFoundContext,\n  InternalErrorContext,\n  InterpreterNotReadyContext,\n  InvalidPortContext,\n  PortAlreadyExposedContext,\n  PortErrorContext,\n  PortNotExposedContext,\n  ProcessErrorContext,\n  ProcessNotFoundContext,\n  SessionAlreadyExistsContext,\n  ValidationFailedContext\n} from '@repo/shared/errors';\nimport { ErrorCode } from '@repo/shared/errors';\n\nimport {\n  CodeExecutionError,\n  CommandError,\n  CommandNotFoundError,\n  ContextNotFoundError,\n  CustomDomainRequiredError,\n  FileExistsError,\n  FileNotFoundError,\n  FileSystemError,\n  GitAuthenticationError,\n  GitBranchNotFoundError,\n  GitCheckoutError,\n  GitCloneError,\n  GitError,\n  GitNetworkError,\n  GitRepositoryNotFoundError,\n  InterpreterNotReadyError,\n  InvalidGitUrlError,\n  InvalidPortError,\n  PermissionDeniedError,\n  PortAlreadyExposedError,\n  PortError,\n  PortInUseError,\n  PortNotExposedError,\n  ProcessError,\n  ProcessNotFoundError,\n  SandboxError,\n  ServiceNotRespondingError,\n  SessionAlreadyExistsError,\n  ValidationFailedError\n} from './classes';\n\n/**\n * Convert ErrorResponse to appropriate Error class\n * Simple switch statement - we trust the container sends correct context\n */\nexport function createErrorFromResponse(errorResponse: ErrorResponse): Error {\n  // We trust the container sends correct context, use type assertions\n  switch (errorResponse.code) {\n    // File System Errors\n    case ErrorCode.FILE_NOT_FOUND:\n      return new FileNotFoundError(\n        errorResponse as unknown as ErrorResponse<FileNotFoundContext>\n      );\n\n    case ErrorCode.FILE_EXISTS:\n      return new FileExistsError(\n        errorResponse as unknown as ErrorResponse<FileExistsContext>\n      );\n\n    case ErrorCode.PERMISSION_DENIED:\n      return new PermissionDeniedError(\n        errorResponse as unknown as ErrorResponse<FileSystemContext>\n      );\n\n    case ErrorCode.IS_DIRECTORY:\n    case ErrorCode.NOT_DIRECTORY:\n    case ErrorCode.NO_SPACE:\n    case ErrorCode.TOO_MANY_FILES:\n    case ErrorCode.RESOURCE_BUSY:\n    case ErrorCode.READ_ONLY:\n    case ErrorCode.NAME_TOO_LONG:\n    case ErrorCode.TOO_MANY_LINKS:\n    case ErrorCode.FILESYSTEM_ERROR:\n      return new FileSystemError(\n        errorResponse as unknown as ErrorResponse<FileSystemContext>\n      );\n\n    // Command Errors\n    case ErrorCode.COMMAND_NOT_FOUND:\n      return new CommandNotFoundError(\n        errorResponse as unknown as ErrorResponse<CommandNotFoundContext>\n      );\n\n    case ErrorCode.COMMAND_PERMISSION_DENIED:\n    case ErrorCode.COMMAND_EXECUTION_ERROR:\n    case ErrorCode.INVALID_COMMAND:\n    case ErrorCode.STREAM_START_ERROR:\n      return new CommandError(\n        errorResponse as unknown as ErrorResponse<CommandErrorContext>\n      );\n\n    // Process Errors\n    case ErrorCode.PROCESS_NOT_FOUND:\n      return new ProcessNotFoundError(\n        errorResponse as unknown as ErrorResponse<ProcessNotFoundContext>\n      );\n\n    case ErrorCode.PROCESS_PERMISSION_DENIED:\n    case ErrorCode.PROCESS_ERROR:\n      return new ProcessError(\n        errorResponse as unknown as ErrorResponse<ProcessErrorContext>\n      );\n\n    // Session Errors\n    case ErrorCode.SESSION_ALREADY_EXISTS:\n      return new SessionAlreadyExistsError(\n        errorResponse as unknown as ErrorResponse<SessionAlreadyExistsContext>\n      );\n\n    // Port Errors\n    case ErrorCode.PORT_ALREADY_EXPOSED:\n      return new PortAlreadyExposedError(\n        errorResponse as unknown as ErrorResponse<PortAlreadyExposedContext>\n      );\n\n    case ErrorCode.PORT_NOT_EXPOSED:\n      return new PortNotExposedError(\n        errorResponse as unknown as ErrorResponse<PortNotExposedContext>\n      );\n\n    case ErrorCode.INVALID_PORT_NUMBER:\n    case ErrorCode.INVALID_PORT:\n      return new InvalidPortError(\n        errorResponse as unknown as ErrorResponse<InvalidPortContext>\n      );\n\n    case ErrorCode.SERVICE_NOT_RESPONDING:\n      return new ServiceNotRespondingError(\n        errorResponse as unknown as ErrorResponse<PortErrorContext>\n      );\n\n    case ErrorCode.PORT_IN_USE:\n      return new PortInUseError(\n        errorResponse as unknown as ErrorResponse<PortErrorContext>\n      );\n\n    case ErrorCode.PORT_OPERATION_ERROR:\n      return new PortError(\n        errorResponse as unknown as ErrorResponse<PortErrorContext>\n      );\n\n    case ErrorCode.CUSTOM_DOMAIN_REQUIRED:\n      return new CustomDomainRequiredError(\n        errorResponse as unknown as ErrorResponse<InternalErrorContext>\n      );\n\n    // Git Errors\n    case ErrorCode.GIT_REPOSITORY_NOT_FOUND:\n      return new GitRepositoryNotFoundError(\n        errorResponse as unknown as ErrorResponse<GitRepositoryNotFoundContext>\n      );\n\n    case ErrorCode.GIT_AUTH_FAILED:\n      return new GitAuthenticationError(\n        errorResponse as unknown as ErrorResponse<GitAuthFailedContext>\n      );\n\n    case ErrorCode.GIT_BRANCH_NOT_FOUND:\n      return new GitBranchNotFoundError(\n        errorResponse as unknown as ErrorResponse<GitBranchNotFoundContext>\n      );\n\n    case ErrorCode.GIT_NETWORK_ERROR:\n      return new GitNetworkError(\n        errorResponse as unknown as ErrorResponse<GitErrorContext>\n      );\n\n    case ErrorCode.GIT_CLONE_FAILED:\n      return new GitCloneError(\n        errorResponse as unknown as ErrorResponse<GitErrorContext>\n      );\n\n    case ErrorCode.GIT_CHECKOUT_FAILED:\n      return new GitCheckoutError(\n        errorResponse as unknown as ErrorResponse<GitErrorContext>\n      );\n\n    case ErrorCode.INVALID_GIT_URL:\n      return new InvalidGitUrlError(\n        errorResponse as unknown as ErrorResponse<ValidationFailedContext>\n      );\n\n    case ErrorCode.GIT_OPERATION_FAILED:\n      return new GitError(\n        errorResponse as unknown as ErrorResponse<GitErrorContext>\n      );\n\n    // Code Interpreter Errors\n    case ErrorCode.INTERPRETER_NOT_READY:\n      return new InterpreterNotReadyError(\n        errorResponse as unknown as ErrorResponse<InterpreterNotReadyContext>\n      );\n\n    case ErrorCode.CONTEXT_NOT_FOUND:\n      return new ContextNotFoundError(\n        errorResponse as unknown as ErrorResponse<ContextNotFoundContext>\n      );\n\n    case ErrorCode.CODE_EXECUTION_ERROR:\n      return new CodeExecutionError(\n        errorResponse as unknown as ErrorResponse<CodeExecutionContext>\n      );\n\n    // Validation Errors\n    case ErrorCode.VALIDATION_FAILED:\n      return new ValidationFailedError(\n        errorResponse as unknown as ErrorResponse<ValidationFailedContext>\n      );\n\n    // Generic Errors\n    case ErrorCode.INVALID_JSON_RESPONSE:\n    case ErrorCode.UNKNOWN_ERROR:\n    case ErrorCode.INTERNAL_ERROR:\n      return new SandboxError(\n        errorResponse as unknown as ErrorResponse<InternalErrorContext>\n      );\n\n    default:\n      // Fallback for unknown error codes\n      return new SandboxError(errorResponse);\n  }\n}\n", "import type { Logger } from '@repo/shared';\nimport { createNoOpLogger } from '@repo/shared';\nimport type { ITransport, TransportConfig, TransportMode } from './types';\n\n/**\n * Container startup retry configuration\n */\nconst TIMEOUT_MS = 120_000; // 2 minutes total retry budget\nconst MIN_TIME_FOR_RETRY_MS = 15_000; // Need at least 15s remaining to retry\n\n/**\n * Abstract base transport with shared retry logic\n *\n * Handles 503 retry for container startup - shared by all transports.\n * Subclasses implement the transport-specific fetch and stream logic.\n */\nexport abstract class BaseTransport implements ITransport {\n  protected config: TransportConfig;\n  protected logger: Logger;\n\n  constructor(config: TransportConfig) {\n    this.config = config;\n    this.logger = config.logger ?? createNoOpLogger();\n  }\n\n  abstract getMode(): TransportMode;\n  abstract connect(): Promise<void>;\n  abstract disconnect(): void;\n  abstract isConnected(): boolean;\n\n  /**\n   * Fetch with automatic retry for 503 (container starting)\n   *\n   * This is the primary entry point for making requests. It wraps the\n   * transport-specific doFetch() with retry logic for container startup.\n   */\n  async fetch(path: string, options?: RequestInit): Promise<Response> {\n    const startTime = Date.now();\n    let attempt = 0;\n\n    while (true) {\n      const response = await this.doFetch(path, options);\n\n      // Check for retryable 503 (container starting)\n      if (response.status === 503) {\n        const elapsed = Date.now() - startTime;\n        const remaining = TIMEOUT_MS - elapsed;\n\n        if (remaining > MIN_TIME_FOR_RETRY_MS) {\n          const delay = Math.min(3000 * 2 ** attempt, 30000);\n\n          this.logger.info('Container not ready, retrying', {\n            status: response.status,\n            attempt: attempt + 1,\n            delayMs: delay,\n            remainingSec: Math.floor(remaining / 1000),\n            mode: this.getMode()\n          });\n\n          await this.sleep(delay);\n          attempt++;\n          continue;\n        }\n\n        this.logger.error(\n          'Container failed to become ready',\n          new Error(\n            `Failed after ${attempt + 1} attempts over ${Math.floor(elapsed / 1000)}s`\n          )\n        );\n      }\n\n      return response;\n    }\n  }\n\n  /**\n   * Transport-specific fetch implementation (no retry)\n   * Subclasses implement the actual HTTP or WebSocket fetch.\n   */\n  protected abstract doFetch(\n    path: string,\n    options?: RequestInit\n  ): Promise<Response>;\n\n  /**\n   * Transport-specific stream implementation\n   * Subclasses implement HTTP SSE or WebSocket streaming.\n   */\n  abstract fetchStream(\n    path: string,\n    body?: unknown,\n    method?: 'GET' | 'POST'\n  ): Promise<ReadableStream<Uint8Array>>;\n\n  /**\n   * Sleep utility for retry delays\n   */\n  protected sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n", "import { BaseTransport } from './base-transport';\nimport type { TransportConfig, TransportMode } from './types';\n\n/**\n * HTTP transport implementation\n *\n * Uses standard fetch API for communication with the container.\n * HTTP is stateless, so connect/disconnect are no-ops.\n */\nexport class HttpTransport extends BaseTransport {\n  private baseUrl: string;\n\n  constructor(config: TransportConfig) {\n    super(config);\n    this.baseUrl = config.baseUrl ?? 'http://localhost:3000';\n  }\n\n  getMode(): TransportMode {\n    return 'http';\n  }\n\n  async connect(): Promise<void> {\n    // No-op for HTTP - stateless protocol\n  }\n\n  disconnect(): void {\n    // No-op for HTTP - stateless protocol\n  }\n\n  isConnected(): boolean {\n    return true; // HTTP is always \"connected\"\n  }\n\n  protected async doFetch(\n    path: string,\n    options?: RequestInit\n  ): Promise<Response> {\n    const url = this.buildUrl(path);\n\n    if (this.config.stub) {\n      return this.config.stub.containerFetch(\n        url,\n        options || {},\n        this.config.port\n      );\n    }\n    return globalThis.fetch(url, options);\n  }\n\n  async fetchStream(\n    path: string,\n    body?: unknown,\n    method: 'GET' | 'POST' = 'POST'\n  ): Promise<ReadableStream<Uint8Array>> {\n    const url = this.buildUrl(path);\n    const options = this.buildStreamOptions(body, method);\n\n    let response: Response;\n    if (this.config.stub) {\n      response = await this.config.stub.containerFetch(\n        url,\n        options,\n        this.config.port\n      );\n    } else {\n      response = await globalThis.fetch(url, options);\n    }\n\n    if (!response.ok) {\n      const errorBody = await response.text();\n      throw new Error(`HTTP error! status: ${response.status} - ${errorBody}`);\n    }\n\n    if (!response.body) {\n      throw new Error('No response body for streaming');\n    }\n\n    return response.body;\n  }\n\n  private buildUrl(path: string): string {\n    if (this.config.stub) {\n      return `http://localhost:${this.config.port}${path}`;\n    }\n    return `${this.baseUrl}${path}`;\n  }\n\n  private buildStreamOptions(\n    body: unknown,\n    method: 'GET' | 'POST'\n  ): RequestInit {\n    return {\n      method,\n      headers:\n        body && method === 'POST'\n          ? { 'Content-Type': 'application/json' }\n          : undefined,\n      body: body && method === 'POST' ? JSON.stringify(body) : undefined\n    };\n  }\n}\n", "import {\n  generateRequestId,\n  isWSError,\n  isWSResponse,\n  isWSStreamChunk,\n  type WSMethod,\n  type WSRequest,\n  type WSResponse,\n  type WSServerMessage,\n  type WSStreamChunk\n} from '@repo/shared';\nimport { BaseTransport } from './base-transport';\nimport type { TransportConfig, TransportMode } from './types';\n\n/**\n * Pending request tracker for response matching\n */\ninterface PendingRequest {\n  resolve: (response: WSResponse) => void;\n  reject: (error: Error) => void;\n  streamController?: ReadableStreamDefaultController<Uint8Array>;\n  isStreaming: boolean;\n  timeoutId?: ReturnType<typeof setTimeout>;\n}\n\n/**\n * WebSocket transport state\n */\ntype WSTransportState = 'disconnected' | 'connecting' | 'connected' | 'error';\n\n/**\n * WebSocket transport implementation\n *\n * Multiplexes HTTP-like requests over a single WebSocket connection.\n * Useful when running inside Workers/DO where sub-request limits apply.\n */\nexport class WebSocketTransport extends BaseTransport {\n  private ws: WebSocket | null = null;\n  private state: WSTransportState = 'disconnected';\n  private pendingRequests: Map<string, PendingRequest> = new Map();\n  private connectPromise: Promise<void> | null = null;\n\n  // Bound event handlers for proper add/remove\n  private boundHandleMessage: (event: MessageEvent) => void;\n  private boundHandleClose: (event: CloseEvent) => void;\n\n  constructor(config: TransportConfig) {\n    super(config);\n\n    if (!config.wsUrl) {\n      throw new Error('wsUrl is required for WebSocket transport');\n    }\n\n    // Bind handlers once in constructor\n    this.boundHandleMessage = this.handleMessage.bind(this);\n    this.boundHandleClose = this.handleClose.bind(this);\n  }\n\n  getMode(): TransportMode {\n    return 'websocket';\n  }\n\n  /**\n   * Check if WebSocket is connected\n   */\n  isConnected(): boolean {\n    return this.state === 'connected' && this.ws?.readyState === WebSocket.OPEN;\n  }\n\n  /**\n   * Connect to the WebSocket server\n   *\n   * The connection promise is assigned synchronously so concurrent\n   * callers share the same connection attempt.\n   */\n  async connect(): Promise<void> {\n    // Already connected\n    if (this.isConnected()) {\n      return;\n    }\n\n    // Connection in progress - wait for it\n    if (this.connectPromise) {\n      return this.connectPromise;\n    }\n\n    // Assign synchronously so concurrent callers await the same promise\n    this.connectPromise = this.doConnect();\n\n    try {\n      await this.connectPromise;\n    } catch (error) {\n      // Clear promise AFTER await so concurrent callers see the same rejection\n      this.connectPromise = null;\n      throw error;\n    }\n  }\n\n  /**\n   * Disconnect from the WebSocket server\n   */\n  disconnect(): void {\n    this.cleanup();\n  }\n\n  /**\n   * Transport-specific fetch implementation\n   * Converts WebSocket response to standard Response object.\n   */\n  protected async doFetch(\n    path: string,\n    options?: RequestInit\n  ): Promise<Response> {\n    await this.connect();\n\n    const method = (options?.method || 'GET') as WSMethod;\n    const body = this.parseBody(options?.body);\n\n    const result = await this.request(method, path, body);\n\n    return new Response(JSON.stringify(result.body), {\n      status: result.status,\n      headers: { 'Content-Type': 'application/json' }\n    });\n  }\n\n  /**\n   * Streaming fetch implementation\n   */\n  async fetchStream(\n    path: string,\n    body?: unknown,\n    method: 'GET' | 'POST' = 'POST'\n  ): Promise<ReadableStream<Uint8Array>> {\n    return this.requestStream(method, path, body);\n  }\n\n  /**\n   * Parse request body from RequestInit\n   */\n  private parseBody(body: RequestInit['body']): unknown {\n    if (!body) {\n      return undefined;\n    }\n\n    if (typeof body === 'string') {\n      try {\n        return JSON.parse(body);\n      } catch (error) {\n        throw new Error(\n          `Request body must be valid JSON: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    throw new Error(\n      `WebSocket transport only supports string bodies. Got: ${typeof body}`\n    );\n  }\n\n  /**\n   * Internal connection logic\n   */\n  private async doConnect(): Promise<void> {\n    this.state = 'connecting';\n    // Use fetch-based WebSocket for DO context (Workers style)\n    if (this.config.stub) {\n      await this.connectViaFetch();\n    } else {\n      // Use standard WebSocket for browser/Node\n      await this.connectViaWebSocket();\n    }\n  }\n\n  /**\n   * Connect using fetch-based WebSocket (Cloudflare Workers style)\n   * This is required when running inside a Durable Object.\n   *\n   * Uses stub.fetch() which routes WebSocket upgrade requests through the\n   * parent Container class that supports the WebSocket protocol.\n   */\n  private async connectViaFetch(): Promise<void> {\n    const timeoutMs = this.config.connectTimeoutMs ?? 30000;\n\n    // Create abort controller for timeout\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), timeoutMs);\n\n    try {\n      // Build the WebSocket URL for the container\n      const wsPath = new URL(this.config.wsUrl!).pathname;\n      const httpUrl = `http://localhost:${this.config.port || 3000}${wsPath}`;\n\n      // Create a Request with WebSocket upgrade headers\n      const request = new Request(httpUrl, {\n        headers: {\n          Upgrade: 'websocket',\n          Connection: 'Upgrade'\n        },\n        signal: controller.signal\n      });\n\n      const response = await this.config.stub!.fetch(request);\n\n      clearTimeout(timeout);\n\n      // Check if upgrade was successful\n      if (response.status !== 101) {\n        throw new Error(\n          `WebSocket upgrade failed: ${response.status} ${response.statusText}`\n        );\n      }\n\n      // Get the WebSocket from the response (Workers-specific API)\n      const ws = (response as unknown as { webSocket?: WebSocket }).webSocket;\n      if (!ws) {\n        throw new Error('No WebSocket in upgrade response');\n      }\n\n      // Accept the WebSocket connection (Workers-specific)\n      (ws as unknown as { accept: () => void }).accept();\n\n      this.ws = ws;\n      this.state = 'connected';\n\n      // Set up event handlers\n      this.ws.addEventListener('close', this.boundHandleClose);\n      this.ws.addEventListener('message', this.boundHandleMessage);\n\n      this.logger.debug('WebSocket connected via fetch', {\n        url: this.config.wsUrl\n      });\n    } catch (error) {\n      clearTimeout(timeout);\n      this.state = 'error';\n      this.logger.error(\n        'WebSocket fetch connection failed',\n        error instanceof Error ? error : new Error(String(error))\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Connect using standard WebSocket API (browser/Node style)\n   */\n  private connectViaWebSocket(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      const timeoutMs = this.config.connectTimeoutMs ?? 30000;\n      const timeout = setTimeout(() => {\n        this.cleanup();\n        reject(new Error(`WebSocket connection timeout after ${timeoutMs}ms`));\n      }, timeoutMs);\n\n      try {\n        this.ws = new WebSocket(this.config.wsUrl!);\n\n        // One-time open handler for connection\n        const onOpen = () => {\n          clearTimeout(timeout);\n          this.ws?.removeEventListener('open', onOpen);\n          this.ws?.removeEventListener('error', onConnectError);\n          this.state = 'connected';\n          this.logger.debug('WebSocket connected', { url: this.config.wsUrl });\n          resolve();\n        };\n\n        // One-time error handler for connection\n        const onConnectError = () => {\n          clearTimeout(timeout);\n          this.ws?.removeEventListener('open', onOpen);\n          this.ws?.removeEventListener('error', onConnectError);\n          this.state = 'error';\n          this.logger.error(\n            'WebSocket error',\n            new Error('WebSocket connection failed')\n          );\n          reject(new Error('WebSocket connection failed'));\n        };\n\n        this.ws.addEventListener('open', onOpen);\n        this.ws.addEventListener('error', onConnectError);\n        this.ws.addEventListener('close', this.boundHandleClose);\n        this.ws.addEventListener('message', this.boundHandleMessage);\n      } catch (error) {\n        clearTimeout(timeout);\n        this.state = 'error';\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Send a request and wait for response\n   */\n  private async request<T>(\n    method: WSMethod,\n    path: string,\n    body?: unknown\n  ): Promise<{ status: number; body: T }> {\n    await this.connect();\n\n    const id = generateRequestId();\n    const request: WSRequest = {\n      type: 'request',\n      id,\n      method,\n      path,\n      body\n    };\n\n    return new Promise((resolve, reject) => {\n      const timeoutMs = this.config.requestTimeoutMs ?? 120000;\n      const timeoutId = setTimeout(() => {\n        this.pendingRequests.delete(id);\n        reject(\n          new Error(`Request timeout after ${timeoutMs}ms: ${method} ${path}`)\n        );\n      }, timeoutMs);\n\n      this.pendingRequests.set(id, {\n        resolve: (response: WSResponse) => {\n          clearTimeout(timeoutId);\n          this.pendingRequests.delete(id);\n          resolve({ status: response.status, body: response.body as T });\n        },\n        reject: (error: Error) => {\n          clearTimeout(timeoutId);\n          this.pendingRequests.delete(id);\n          reject(error);\n        },\n        isStreaming: false,\n        timeoutId\n      });\n\n      try {\n        this.send(request);\n      } catch (error) {\n        clearTimeout(timeoutId);\n        this.pendingRequests.delete(id);\n        reject(error instanceof Error ? error : new Error(String(error)));\n      }\n    });\n  }\n\n  /**\n   * Send a streaming request and return a ReadableStream\n   *\n   * The stream will receive data chunks as they arrive over the WebSocket.\n   * Format matches SSE for compatibility with existing streaming code.\n   */\n  private async requestStream(\n    method: WSMethod,\n    path: string,\n    body?: unknown\n  ): Promise<ReadableStream<Uint8Array>> {\n    await this.connect();\n\n    const id = generateRequestId();\n    const request: WSRequest = {\n      type: 'request',\n      id,\n      method,\n      path,\n      body\n    };\n\n    return new ReadableStream<Uint8Array>({\n      start: (controller) => {\n        const timeoutMs = this.config.requestTimeoutMs ?? 120000;\n        const timeoutId = setTimeout(() => {\n          this.pendingRequests.delete(id);\n          controller.error(\n            new Error(`Stream timeout after ${timeoutMs}ms: ${method} ${path}`)\n          );\n        }, timeoutMs);\n\n        this.pendingRequests.set(id, {\n          resolve: (response: WSResponse) => {\n            clearTimeout(timeoutId);\n            this.pendingRequests.delete(id);\n            // Final response - close the stream\n            if (response.status >= 400) {\n              controller.error(\n                new Error(\n                  `Stream error: ${response.status} - ${JSON.stringify(response.body)}`\n                )\n              );\n            } else {\n              controller.close();\n            }\n          },\n          reject: (error: Error) => {\n            clearTimeout(timeoutId);\n            this.pendingRequests.delete(id);\n            controller.error(error);\n          },\n          streamController: controller,\n          isStreaming: true,\n          timeoutId\n        });\n\n        try {\n          this.send(request);\n        } catch (error) {\n          clearTimeout(timeoutId);\n          this.pendingRequests.delete(id);\n          controller.error(\n            error instanceof Error ? error : new Error(String(error))\n          );\n        }\n      },\n      cancel: () => {\n        const pending = this.pendingRequests.get(id);\n        if (pending?.timeoutId) {\n          clearTimeout(pending.timeoutId);\n        }\n        this.pendingRequests.delete(id);\n        // Could send a cancel message to server if needed\n      }\n    });\n  }\n\n  /**\n   * Send a message over the WebSocket\n   */\n  private send(message: WSRequest): void {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      throw new Error('WebSocket not connected');\n    }\n\n    this.ws.send(JSON.stringify(message));\n    this.logger.debug('WebSocket sent', {\n      id: message.id,\n      method: message.method,\n      path: message.path\n    });\n  }\n\n  /**\n   * Handle incoming WebSocket messages\n   */\n  private handleMessage(event: MessageEvent): void {\n    try {\n      const message = JSON.parse(event.data) as WSServerMessage;\n\n      if (isWSResponse(message)) {\n        this.handleResponse(message);\n      } else if (isWSStreamChunk(message)) {\n        this.handleStreamChunk(message);\n      } else if (isWSError(message)) {\n        this.handleError(message);\n      } else {\n        this.logger.warn('Unknown WebSocket message type', { message });\n      }\n    } catch (error) {\n      this.logger.error(\n        'Failed to parse WebSocket message',\n        error instanceof Error ? error : new Error(String(error))\n      );\n    }\n  }\n\n  /**\n   * Handle a response message\n   */\n  private handleResponse(response: WSResponse): void {\n    const pending = this.pendingRequests.get(response.id);\n    if (!pending) {\n      this.logger.warn('Received response for unknown request', {\n        id: response.id\n      });\n      return;\n    }\n\n    this.logger.debug('WebSocket response', {\n      id: response.id,\n      status: response.status,\n      done: response.done\n    });\n\n    // Only resolve when done is true\n    if (response.done) {\n      pending.resolve(response);\n    }\n  }\n\n  /**\n   * Handle a stream chunk message\n   */\n  private handleStreamChunk(chunk: WSStreamChunk): void {\n    const pending = this.pendingRequests.get(chunk.id);\n    if (!pending || !pending.streamController) {\n      this.logger.warn('Received stream chunk for unknown request', {\n        id: chunk.id\n      });\n      return;\n    }\n\n    // Convert to SSE format for compatibility with existing parsers\n    const encoder = new TextEncoder();\n    let sseData: string;\n    if (chunk.event) {\n      sseData = `event: ${chunk.event}\\ndata: ${chunk.data}\\n\\n`;\n    } else {\n      sseData = `data: ${chunk.data}\\n\\n`;\n    }\n\n    try {\n      pending.streamController.enqueue(encoder.encode(sseData));\n    } catch (error) {\n      // Stream was cancelled or errored - clean up the pending request\n      this.logger.debug('Failed to enqueue stream chunk, cleaning up', {\n        id: chunk.id,\n        error: error instanceof Error ? error.message : String(error)\n      });\n      // Clear timeout and remove from pending requests\n      if (pending.timeoutId) {\n        clearTimeout(pending.timeoutId);\n      }\n      this.pendingRequests.delete(chunk.id);\n    }\n  }\n\n  /**\n   * Handle an error message\n   */\n  private handleError(error: {\n    id?: string;\n    code: string;\n    message: string;\n    status: number;\n  }): void {\n    if (error.id) {\n      const pending = this.pendingRequests.get(error.id);\n      if (pending) {\n        pending.reject(new Error(`${error.code}: ${error.message}`));\n        return;\n      }\n    }\n\n    // Global error - log it\n    this.logger.error('WebSocket error message', new Error(error.message), {\n      code: error.code,\n      status: error.status\n    });\n  }\n\n  /**\n   * Handle WebSocket close\n   */\n  private handleClose(event: CloseEvent): void {\n    this.state = 'disconnected';\n    this.ws = null;\n\n    const closeError = new Error(\n      `WebSocket closed: ${event.code} ${event.reason || 'No reason'}`\n    );\n\n    // Reject all pending requests, clear their timeouts, and error their stream controllers\n    for (const [, pending] of this.pendingRequests) {\n      // Clear timeout first to prevent memory leak\n      if (pending.timeoutId) {\n        clearTimeout(pending.timeoutId);\n      }\n      // Error stream controller if it exists\n      if (pending.streamController) {\n        try {\n          pending.streamController.error(closeError);\n        } catch {\n          // Stream may already be closed/errored\n        }\n      }\n      pending.reject(closeError);\n    }\n    this.pendingRequests.clear();\n  }\n\n  /**\n   * Cleanup resources\n   */\n  private cleanup(): void {\n    if (this.ws) {\n      this.ws.removeEventListener('close', this.boundHandleClose);\n      this.ws.removeEventListener('message', this.boundHandleMessage);\n      this.ws.close();\n      this.ws = null;\n    }\n    this.state = 'disconnected';\n    this.connectPromise = null;\n    // Clear all pending request timeouts before clearing the map\n    for (const pending of this.pendingRequests.values()) {\n      if (pending.timeoutId) {\n        clearTimeout(pending.timeoutId);\n      }\n    }\n    this.pendingRequests.clear();\n  }\n}\n", "import { HttpTransport } from './http-transport';\nimport type { ITransport, TransportConfig, TransportMode } from './types';\nimport { WebSocketTransport } from './ws-transport';\n\n/**\n * Transport options with mode selection\n */\nexport interface TransportOptions extends TransportConfig {\n  /** Transport mode */\n  mode: TransportMode;\n}\n\n/**\n * Create a transport instance based on mode\n *\n * This is the primary API for creating transports. It handles\n * the selection of HTTP or WebSocket transport based on the mode.\n *\n * @example\n * ```typescript\n * // HTTP transport (default)\n * const http = createTransport({\n *   mode: 'http',\n *   baseUrl: 'http://localhost:3000'\n * });\n *\n * // WebSocket transport\n * const ws = createTransport({\n *   mode: 'websocket',\n *   wsUrl: 'ws://localhost:3000/ws'\n * });\n * ```\n */\nexport function createTransport(options: TransportOptions): ITransport {\n  switch (options.mode) {\n    case 'websocket':\n      return new WebSocketTransport(options);\n\n    default:\n      return new HttpTransport(options);\n  }\n}\n", "import type { Logger } from '@repo/shared';\nimport { createNoOpLogger } from '@repo/shared';\nimport type { ErrorResponse as NewErrorResponse } from '../errors';\nimport { createErrorFromResponse, ErrorCode } from '../errors';\nimport type { SandboxError } from '../errors/classes';\nimport { createTransport, type ITransport } from './transport';\nimport type { HttpClientOptions, ResponseHandler } from './types';\n\n/**\n * Abstract base class providing common HTTP/WebSocket functionality for all domain clients\n *\n * All requests go through the Transport abstraction layer, which handles:\n * - HTTP and WebSocket modes transparently\n * - Automatic retry for 503 errors (container starting)\n * - Streaming responses\n *\n * WebSocket mode is useful when running inside Workers/Durable Objects\n * where sub-request limits apply.\n */\nexport abstract class BaseHttpClient {\n  protected options: HttpClientOptions;\n  protected logger: Logger;\n  protected transport: ITransport;\n\n  constructor(options: HttpClientOptions = {}) {\n    this.options = options;\n    this.logger = options.logger ?? createNoOpLogger();\n\n    // Always create a Transport - it handles both HTTP and WebSocket modes\n    if (options.transport) {\n      this.transport = options.transport;\n    } else {\n      const mode = options.transportMode ?? 'http';\n      this.transport = createTransport({\n        mode,\n        baseUrl: options.baseUrl ?? 'http://localhost:3000',\n        wsUrl: options.wsUrl,\n        logger: this.logger,\n        stub: options.stub,\n        port: options.port\n      });\n    }\n  }\n\n  /**\n   * Check if using WebSocket transport\n   */\n  protected isWebSocketMode(): boolean {\n    return this.transport.getMode() === 'websocket';\n  }\n\n  /**\n   * Core fetch method - delegates to Transport which handles retry logic\n   */\n  protected async doFetch(\n    path: string,\n    options?: RequestInit\n  ): Promise<Response> {\n    return this.transport.fetch(path, options);\n  }\n\n  /**\n   * Make a POST request with JSON body\n   */\n  protected async post<T>(\n    endpoint: string,\n    data: unknown,\n    responseHandler?: ResponseHandler<T>\n  ): Promise<T> {\n    const response = await this.doFetch(endpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(data)\n    });\n\n    return this.handleResponse(response, responseHandler);\n  }\n\n  /**\n   * Make a GET request\n   */\n  protected async get<T>(\n    endpoint: string,\n    responseHandler?: ResponseHandler<T>\n  ): Promise<T> {\n    const response = await this.doFetch(endpoint, {\n      method: 'GET'\n    });\n\n    return this.handleResponse(response, responseHandler);\n  }\n\n  /**\n   * Make a DELETE request\n   */\n  protected async delete<T>(\n    endpoint: string,\n    responseHandler?: ResponseHandler<T>\n  ): Promise<T> {\n    const response = await this.doFetch(endpoint, {\n      method: 'DELETE'\n    });\n\n    return this.handleResponse(response, responseHandler);\n  }\n\n  /**\n   * Handle HTTP response with error checking and parsing\n   */\n  protected async handleResponse<T>(\n    response: Response,\n    customHandler?: ResponseHandler<T>\n  ): Promise<T> {\n    if (!response.ok) {\n      await this.handleErrorResponse(response);\n    }\n\n    if (customHandler) {\n      return customHandler(response);\n    }\n\n    try {\n      return await response.json();\n    } catch (error) {\n      // Handle malformed JSON responses gracefully\n      const errorResponse: NewErrorResponse = {\n        code: ErrorCode.INVALID_JSON_RESPONSE,\n        message: `Invalid JSON response: ${\n          error instanceof Error ? error.message : 'Unknown parsing error'\n        }`,\n        context: {},\n        httpStatus: response.status,\n        timestamp: new Date().toISOString()\n      };\n      throw createErrorFromResponse(errorResponse);\n    }\n  }\n\n  /**\n   * Handle error responses with consistent error throwing\n   */\n  protected async handleErrorResponse(response: Response): Promise<never> {\n    let errorData: NewErrorResponse;\n\n    try {\n      errorData = await response.json();\n    } catch {\n      // Fallback if response isn't JSON or parsing fails\n      errorData = {\n        code: ErrorCode.INTERNAL_ERROR,\n        message: `HTTP error! status: ${response.status}`,\n        context: { statusText: response.statusText },\n        httpStatus: response.status,\n        timestamp: new Date().toISOString()\n      };\n    }\n\n    // Convert ErrorResponse to appropriate Error class\n    const error = createErrorFromResponse(errorData);\n\n    // Call error callback if provided\n    this.options.onError?.(errorData.message, undefined);\n\n    throw error;\n  }\n\n  /**\n   * Create a streaming response handler for Server-Sent Events\n   */\n  protected async handleStreamResponse(\n    response: Response\n  ): Promise<ReadableStream<Uint8Array>> {\n    if (!response.ok) {\n      await this.handleErrorResponse(response);\n    }\n\n    if (!response.body) {\n      throw new Error('No response body for streaming');\n    }\n\n    return response.body;\n  }\n\n  /**\n   * Stream request handler\n   *\n   * For HTTP mode, uses doFetch + handleStreamResponse to get proper error typing.\n   * For WebSocket mode, uses Transport's streaming support.\n   *\n   * @param path - The API path to call\n   * @param body - Optional request body (for POST requests)\n   * @param method - HTTP method (default: POST, use GET for process logs)\n   */\n  protected async doStreamFetch(\n    path: string,\n    body?: unknown,\n    method: 'GET' | 'POST' = 'POST'\n  ): Promise<ReadableStream<Uint8Array>> {\n    // WebSocket mode uses Transport's streaming directly\n    if (this.transport.getMode() === 'websocket') {\n      try {\n        return await this.transport.fetchStream(path, body, method);\n      } catch (error) {\n        this.logError(`stream ${method} ${path}`, error);\n        throw error;\n      }\n    }\n\n    // HTTP mode: use doFetch + handleStreamResponse for proper error typing\n    const response = await this.doFetch(path, {\n      method,\n      headers: { 'Content-Type': 'application/json' },\n      body: body && method === 'POST' ? JSON.stringify(body) : undefined\n    });\n\n    return this.handleStreamResponse(response);\n  }\n\n  /**\n   * Utility method to log successful operations\n   */\n  protected logSuccess(operation: string, details?: string): void {\n    this.logger.info(operation, details ? { details } : undefined);\n  }\n\n  /**\n   * Utility method to log errors intelligently\n   * Only logs unexpected errors (5xx), not expected errors (4xx)\n   *\n   * - 4xx errors (validation, not found, conflicts): Don't log (expected client errors)\n   * - 5xx errors (server failures, internal errors): DO log (unexpected server errors)\n   */\n  protected logError(operation: string, error: unknown): void {\n    // Check if it's a SandboxError with HTTP status\n    if (error && typeof error === 'object' && 'httpStatus' in error) {\n      const httpStatus = (error as SandboxError).httpStatus;\n\n      // Only log server errors (5xx), not client errors (4xx)\n      if (httpStatus >= 500) {\n        this.logger.error(\n          `Unexpected error in ${operation}`,\n          error instanceof Error ? error : new Error(String(error)),\n          { httpStatus }\n        );\n      }\n      // 4xx errors are expected (validation, not found, etc.) - don't log\n    } else {\n      // Non-SandboxError (unexpected) - log it\n      this.logger.error(\n        `Error in ${operation}`,\n        error instanceof Error ? error : new Error(String(error))\n      );\n    }\n  }\n}\n", "import type { ExecuteRequest } from '@repo/shared';\nimport { BaseHttpClient } from './base-client';\nimport type { BaseApiResponse } from './types';\n\n/**\n * Request interface for command execution\n */\nexport type { ExecuteRequest };\n\n/**\n * Response interface for command execution\n */\nexport interface ExecuteResponse extends BaseApiResponse {\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n  command: string;\n}\n\n/**\n * Client for command execution operations\n */\nexport class CommandClient extends BaseHttpClient {\n  /**\n   * Execute a command and return the complete result\n   * @param command - The command to execute\n   * @param sessionId - The session ID for this command execution\n   * @param timeoutMs - Optional timeout in milliseconds (unlimited by default)\n   * @param env - Optional environment variables for this command\n   * @param cwd - Optional working directory for this command\n   */\n  async execute(\n    command: string,\n    sessionId: string,\n    options?: {\n      timeoutMs?: number;\n      env?: Record<string, string | undefined>;\n      cwd?: string;\n    }\n  ): Promise<ExecuteResponse> {\n    try {\n      const data: ExecuteRequest = {\n        command,\n        sessionId,\n        ...(options?.timeoutMs !== undefined && {\n          timeoutMs: options.timeoutMs\n        }),\n        ...(options?.env !== undefined && { env: options.env }),\n        ...(options?.cwd !== undefined && { cwd: options.cwd })\n      };\n\n      const response = await this.post<ExecuteResponse>('/api/execute', data);\n\n      this.logSuccess(\n        'Command executed',\n        `${command}, Success: ${response.success}`\n      );\n\n      // Call the callback if provided\n      this.options.onCommandComplete?.(\n        response.success,\n        response.exitCode,\n        response.stdout,\n        response.stderr,\n        response.command\n      );\n\n      return response;\n    } catch (error) {\n      this.logError('execute', error);\n\n      // Call error callback if provided\n      this.options.onError?.(\n        error instanceof Error ? error.message : String(error),\n        command\n      );\n\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a command and return a stream of events\n   * @param command - The command to execute\n   * @param sessionId - The session ID for this command execution\n   * @param options - Optional per-command execution settings\n   */\n  async executeStream(\n    command: string,\n    sessionId: string,\n    options?: {\n      timeoutMs?: number;\n      env?: Record<string, string | undefined>;\n      cwd?: string;\n    }\n  ): Promise<ReadableStream<Uint8Array>> {\n    try {\n      const data = {\n        command,\n        sessionId,\n        ...(options?.timeoutMs !== undefined && {\n          timeoutMs: options.timeoutMs\n        }),\n        ...(options?.env !== undefined && { env: options.env }),\n        ...(options?.cwd !== undefined && { cwd: options.cwd })\n      };\n\n      // Use doStreamFetch which handles both WebSocket and HTTP streaming\n      const stream = await this.doStreamFetch('/api/execute/stream', data);\n\n      this.logSuccess('Command stream started', command);\n\n      return stream;\n    } catch (error) {\n      this.logError('executeStream', error);\n\n      // Call error callback if provided\n      this.options.onError?.(\n        error instanceof Error ? error.message : String(error),\n        command\n      );\n\n      throw error;\n    }\n  }\n}\n", "import type {\n  DeleteFileResult,\n  FileExistsResult,\n  ListFilesOptions,\n  ListFilesResult,\n  MkdirResult,\n  MoveFileResult,\n  ReadFileResult,\n  RenameFileResult,\n  WriteFileResult\n} from '@repo/shared';\nimport { BaseHttpClient } from './base-client';\nimport type { HttpClientOptions, SessionRequest } from './types';\n\n/**\n * Request interface for creating directories\n */\nexport interface MkdirRequest extends SessionRequest {\n  path: string;\n  recursive?: boolean;\n}\n\n/**\n * Request interface for writing files\n */\nexport interface WriteFileRequest extends SessionRequest {\n  path: string;\n  content: string;\n  encoding?: string;\n}\n\n/**\n * Request interface for reading files\n */\nexport interface ReadFileRequest extends SessionRequest {\n  path: string;\n  encoding?: string;\n}\n\n/**\n * Request interface for file operations (delete, rename, move)\n */\nexport interface FileOperationRequest extends SessionRequest {\n  path: string;\n  newPath?: string; // For rename/move operations\n}\n\n/**\n * Client for file system operations\n */\nexport class FileClient extends BaseHttpClient {\n  /**\n   * Create a directory\n   * @param path - Directory path to create\n   * @param sessionId - The session ID for this operation\n   * @param options - Optional settings (recursive)\n   */\n  async mkdir(\n    path: string,\n    sessionId: string,\n    options?: { recursive?: boolean }\n  ): Promise<MkdirResult> {\n    try {\n      const data = {\n        path,\n        sessionId,\n        recursive: options?.recursive ?? false\n      };\n\n      const response = await this.post<MkdirResult>('/api/mkdir', data);\n\n      this.logSuccess(\n        'Directory created',\n        `${path} (recursive: ${data.recursive})`\n      );\n      return response;\n    } catch (error) {\n      this.logError('mkdir', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Write content to a file\n   * @param path - File path to write to\n   * @param content - Content to write\n   * @param sessionId - The session ID for this operation\n   * @param options - Optional settings (encoding)\n   */\n  async writeFile(\n    path: string,\n    content: string,\n    sessionId: string,\n    options?: { encoding?: string }\n  ): Promise<WriteFileResult> {\n    try {\n      const data = {\n        path,\n        content,\n        sessionId,\n        encoding: options?.encoding\n      };\n\n      const response = await this.post<WriteFileResult>('/api/write', data);\n\n      this.logSuccess('File written', `${path} (${content.length} chars)`);\n      return response;\n    } catch (error) {\n      this.logError('writeFile', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Read content from a file\n   * @param path - File path to read from\n   * @param sessionId - The session ID for this operation\n   * @param options - Optional settings (encoding)\n   */\n  async readFile(\n    path: string,\n    sessionId: string,\n    options?: { encoding?: string }\n  ): Promise<ReadFileResult> {\n    try {\n      const data = {\n        path,\n        sessionId,\n        encoding: options?.encoding\n      };\n\n      const response = await this.post<ReadFileResult>('/api/read', data);\n\n      this.logSuccess(\n        'File read',\n        `${path} (${response.content.length} chars)`\n      );\n      return response;\n    } catch (error) {\n      this.logError('readFile', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Stream a file using Server-Sent Events\n   * Returns a ReadableStream of SSE events containing metadata, chunks, and completion\n   * @param path - File path to stream\n   * @param sessionId - The session ID for this operation\n   */\n  async readFileStream(\n    path: string,\n    sessionId: string\n  ): Promise<ReadableStream<Uint8Array>> {\n    try {\n      const data = {\n        path,\n        sessionId\n      };\n\n      // Use doStreamFetch which handles both WebSocket and HTTP streaming\n      const stream = await this.doStreamFetch('/api/read/stream', data);\n      this.logSuccess('File stream started', path);\n      return stream;\n    } catch (error) {\n      this.logError('readFileStream', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete a file\n   * @param path - File path to delete\n   * @param sessionId - The session ID for this operation\n   */\n  async deleteFile(path: string, sessionId: string): Promise<DeleteFileResult> {\n    try {\n      const data = { path, sessionId };\n\n      const response = await this.post<DeleteFileResult>('/api/delete', data);\n\n      this.logSuccess('File deleted', path);\n      return response;\n    } catch (error) {\n      this.logError('deleteFile', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Rename a file\n   * @param path - Current file path\n   * @param newPath - New file path\n   * @param sessionId - The session ID for this operation\n   */\n  async renameFile(\n    path: string,\n    newPath: string,\n    sessionId: string\n  ): Promise<RenameFileResult> {\n    try {\n      const data = { oldPath: path, newPath, sessionId };\n\n      const response = await this.post<RenameFileResult>('/api/rename', data);\n\n      this.logSuccess('File renamed', `${path} -> ${newPath}`);\n      return response;\n    } catch (error) {\n      this.logError('renameFile', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Move a file\n   * @param path - Current file path\n   * @param newPath - Destination file path\n   * @param sessionId - The session ID for this operation\n   */\n  async moveFile(\n    path: string,\n    newPath: string,\n    sessionId: string\n  ): Promise<MoveFileResult> {\n    try {\n      const data = { sourcePath: path, destinationPath: newPath, sessionId };\n\n      const response = await this.post<MoveFileResult>('/api/move', data);\n\n      this.logSuccess('File moved', `${path} -> ${newPath}`);\n      return response;\n    } catch (error) {\n      this.logError('moveFile', error);\n      throw error;\n    }\n  }\n\n  /**\n   * List files in a directory\n   * @param path - Directory path to list\n   * @param sessionId - The session ID for this operation\n   * @param options - Optional settings (recursive, includeHidden)\n   */\n  async listFiles(\n    path: string,\n    sessionId: string,\n    options?: ListFilesOptions\n  ): Promise<ListFilesResult> {\n    try {\n      const data = {\n        path,\n        sessionId,\n        options: options || {}\n      };\n\n      const response = await this.post<ListFilesResult>(\n        '/api/list-files',\n        data\n      );\n\n      this.logSuccess('Files listed', `${path} (${response.count} files)`);\n      return response;\n    } catch (error) {\n      this.logError('listFiles', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check if a file or directory exists\n   * @param path - Path to check\n   * @param sessionId - The session ID for this operation\n   */\n  async exists(path: string, sessionId: string): Promise<FileExistsResult> {\n    try {\n      const data = {\n        path,\n        sessionId\n      };\n\n      const response = await this.post<FileExistsResult>('/api/exists', data);\n\n      this.logSuccess(\n        'Path existence checked',\n        `${path} (exists: ${response.exists})`\n      );\n      return response;\n    } catch (error) {\n      this.logError('exists', error);\n      throw error;\n    }\n  }\n}\n", "import type { GitCheckoutResult } from '@repo/shared';\nimport { extractRepoName, GitLogger } from '@repo/shared';\nimport { BaseHttpClient } from './base-client';\nimport type { HttpClientOptions, SessionRequest } from './types';\n\n// Re-export for convenience\nexport type { GitCheckoutResult };\n\n/**\n * Request interface for Git checkout operations\n */\nexport interface GitCheckoutRequest extends SessionRequest {\n  repoUrl: string;\n  branch?: string;\n  targetDir?: string;\n  /** Clone depth for shallow clones (e.g., 1 for latest commit only) */\n  depth?: number;\n}\n\n/**\n * Client for Git repository operations\n */\nexport class GitClient extends BaseHttpClient {\n  constructor(options: HttpClientOptions = {}) {\n    super(options);\n    // Wrap logger with GitLogger to auto-redact credentials\n    this.logger = new GitLogger(this.logger);\n  }\n\n  /**\n   * Clone a Git repository\n   * @param repoUrl - URL of the Git repository to clone\n   * @param sessionId - The session ID for this operation\n   * @param options - Optional settings (branch, targetDir, depth)\n   */\n  async checkout(\n    repoUrl: string,\n    sessionId: string,\n    options?: {\n      branch?: string;\n      targetDir?: string;\n      /** Clone depth for shallow clones (e.g., 1 for latest commit only) */\n      depth?: number;\n    }\n  ): Promise<GitCheckoutResult> {\n    try {\n      // Determine target directory - use provided path or generate from repo name\n      let targetDir = options?.targetDir;\n      if (!targetDir) {\n        targetDir = `/workspace/${extractRepoName(repoUrl)}`;\n      }\n\n      const data: GitCheckoutRequest = {\n        repoUrl,\n        sessionId,\n        targetDir\n      };\n\n      // Only include branch if explicitly specified\n      // This allows Git to use the repository's default branch\n      if (options?.branch) {\n        data.branch = options.branch;\n      }\n\n      if (options?.depth !== undefined) {\n        if (!Number.isInteger(options.depth) || options.depth <= 0) {\n          throw new Error(\n            `Invalid depth value: ${options.depth}. Must be a positive integer (e.g., 1, 5, 10).`\n          );\n        }\n        data.depth = options.depth;\n      }\n\n      const response = await this.post<GitCheckoutResult>(\n        '/api/git/checkout',\n        data\n      );\n\n      this.logSuccess(\n        'Repository cloned',\n        `${repoUrl} (branch: ${response.branch}) -> ${response.targetDir}`\n      );\n\n      return response;\n    } catch (error) {\n      this.logError('checkout', error);\n      throw error;\n    }\n  }\n}\n", "import {\n  type CodeContext,\n  type ContextCreateResult,\n  type ContextListResult,\n  type CreateContextOptions,\n  type ExecutionError,\n  type OutputMessage,\n  type Result,\n  ResultImpl\n} from '@repo/shared';\nimport type { ErrorResponse } from '../errors';\nimport {\n  createErrorFromResponse,\n  ErrorCode,\n  InterpreterNotReadyError\n} from '../errors';\nimport { BaseHttpClient } from './base-client.js';\nimport type { HttpClientOptions } from './types.js';\n\n// Streaming execution data from the server\ninterface StreamingExecutionData {\n  type: 'result' | 'stdout' | 'stderr' | 'error' | 'execution_complete';\n  text?: string;\n  html?: string;\n  png?: string; // base64\n  jpeg?: string; // base64\n  svg?: string;\n  latex?: string;\n  markdown?: string;\n  javascript?: string;\n  json?: unknown;\n  chart?: {\n    type:\n      | 'line'\n      | 'bar'\n      | 'scatter'\n      | 'pie'\n      | 'histogram'\n      | 'heatmap'\n      | 'unknown';\n    data: unknown;\n    options?: unknown;\n  };\n  data?: unknown;\n  metadata?: Record<string, unknown>;\n  execution_count?: number;\n  ename?: string;\n  evalue?: string;\n  traceback?: string[];\n  lineNumber?: number;\n  timestamp?: number;\n}\n\nexport interface ExecutionCallbacks {\n  onStdout?: (output: OutputMessage) => void | Promise<void>;\n  onStderr?: (output: OutputMessage) => void | Promise<void>;\n  onResult?: (result: Result) => void | Promise<void>;\n  onError?: (error: ExecutionError) => void | Promise<void>;\n}\n\nexport class InterpreterClient extends BaseHttpClient {\n  private readonly maxRetries = 3;\n  private readonly retryDelayMs = 1000;\n\n  async createCodeContext(\n    options: CreateContextOptions = {}\n  ): Promise<CodeContext> {\n    return this.executeWithRetry(async () => {\n      const response = await this.doFetch('/api/contexts', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          language: options.language || 'python',\n          cwd: options.cwd || '/workspace',\n          env_vars: options.envVars\n        })\n      });\n\n      if (!response.ok) {\n        const error = await this.parseErrorResponse(response);\n        throw error;\n      }\n\n      const data = (await response.json()) as ContextCreateResult;\n      if (!data.success) {\n        throw new Error(`Failed to create context: ${JSON.stringify(data)}`);\n      }\n\n      return {\n        id: data.contextId,\n        language: data.language,\n        cwd: data.cwd || '/workspace',\n        createdAt: new Date(data.timestamp),\n        lastUsed: new Date(data.timestamp)\n      };\n    });\n  }\n\n  async runCodeStream(\n    contextId: string | undefined,\n    code: string,\n    language: string | undefined,\n    callbacks: ExecutionCallbacks,\n    timeoutMs?: number\n  ): Promise<void> {\n    return this.executeWithRetry(async () => {\n      // Use doStreamFetch which handles both WebSocket and HTTP streaming\n      const stream = await this.doStreamFetch('/api/execute/code', {\n        context_id: contextId,\n        code,\n        language,\n        ...(timeoutMs !== undefined && { timeout_ms: timeoutMs })\n      });\n\n      // Process streaming response\n      for await (const chunk of this.readLines(stream)) {\n        await this.parseExecutionResult(chunk, callbacks);\n      }\n    });\n  }\n\n  async listCodeContexts(): Promise<CodeContext[]> {\n    return this.executeWithRetry(async () => {\n      const response = await this.doFetch('/api/contexts', {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' }\n      });\n\n      if (!response.ok) {\n        const error = await this.parseErrorResponse(response);\n        throw error;\n      }\n\n      const data = (await response.json()) as ContextListResult;\n      if (!data.success) {\n        throw new Error(`Failed to list contexts: ${JSON.stringify(data)}`);\n      }\n\n      return data.contexts.map((ctx) => ({\n        id: ctx.id,\n        language: ctx.language,\n        cwd: ctx.cwd || '/workspace',\n        createdAt: new Date(data.timestamp),\n        lastUsed: new Date(data.timestamp)\n      }));\n    });\n  }\n\n  async deleteCodeContext(contextId: string): Promise<void> {\n    return this.executeWithRetry(async () => {\n      const response = await this.doFetch(`/api/contexts/${contextId}`, {\n        method: 'DELETE',\n        headers: { 'Content-Type': 'application/json' }\n      });\n\n      if (!response.ok) {\n        const error = await this.parseErrorResponse(response);\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Get a raw stream for code execution.\n   * Used by CodeInterpreter.runCodeStreaming() for direct stream access.\n   */\n  async streamCode(\n    contextId: string,\n    code: string,\n    language?: string\n  ): Promise<ReadableStream<Uint8Array>> {\n    return this.doStreamFetch('/api/execute/code', {\n      context_id: contextId,\n      code,\n      language\n    });\n  }\n\n  /**\n   * Execute an operation with automatic retry for transient errors\n   */\n  private async executeWithRetry<T>(operation: () => Promise<T>): Promise<T> {\n    let lastError: Error | undefined;\n\n    for (let attempt = 0; attempt < this.maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        this.logError('executeWithRetry', error);\n        lastError = error as Error;\n\n        // Check if it's a retryable error (interpreter not ready)\n        if (this.isRetryableError(error)) {\n          // Don't retry on the last attempt\n          if (attempt < this.maxRetries - 1) {\n            // Exponential backoff with jitter\n            const delay =\n              this.retryDelayMs * 2 ** attempt + Math.random() * 1000;\n            await new Promise((resolve) => setTimeout(resolve, delay));\n            continue;\n          }\n        }\n\n        // Not retryable or last attempt - throw the error\n        throw error;\n      }\n    }\n\n    throw lastError || new Error('Execution failed after retries');\n  }\n\n  private isRetryableError(error: unknown): boolean {\n    if (error instanceof InterpreterNotReadyError) {\n      return true;\n    }\n\n    if (error instanceof Error) {\n      return (\n        error.message.includes('not ready') ||\n        error.message.includes('initializing')\n      );\n    }\n\n    return false;\n  }\n\n  private async parseErrorResponse(response: Response): Promise<Error> {\n    try {\n      const errorData = (await response.json()) as ErrorResponse;\n      return createErrorFromResponse(errorData);\n    } catch {\n      // Fallback if response isn't JSON\n      const errorResponse: ErrorResponse = {\n        code: ErrorCode.INTERNAL_ERROR,\n        message: `HTTP ${response.status}: ${response.statusText}`,\n        context: {},\n        httpStatus: response.status,\n        timestamp: new Date().toISOString()\n      };\n      return createErrorFromResponse(errorResponse);\n    }\n  }\n\n  private async *readLines(\n    stream: ReadableStream<Uint8Array>\n  ): AsyncGenerator<string> {\n    const reader = stream.getReader();\n    let buffer = '';\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (value) {\n          buffer += new TextDecoder().decode(value);\n        }\n        if (done) break;\n\n        let newlineIdx = buffer.indexOf('\\n');\n        while (newlineIdx !== -1) {\n          yield buffer.slice(0, newlineIdx);\n          buffer = buffer.slice(newlineIdx + 1);\n          newlineIdx = buffer.indexOf('\\n');\n        }\n      }\n\n      // Yield any remaining data\n      if (buffer.length > 0) {\n        yield buffer;\n      }\n    } finally {\n      // Cancel the stream first to properly terminate HTTP connections when breaking early\n      try {\n        await reader.cancel();\n      } catch {\n        // Ignore cancel errors (stream may already be closed)\n      }\n      reader.releaseLock();\n    }\n  }\n\n  private async parseExecutionResult(\n    line: string,\n    callbacks: ExecutionCallbacks\n  ) {\n    if (!line.trim()) return;\n\n    // Skip lines that don't start with \"data: \" (SSE format)\n    if (!line.startsWith('data: ')) return;\n\n    try {\n      // Strip \"data: \" prefix and parse JSON\n      const jsonData = line.substring(6); // \"data: \" is 6 characters\n      const data = JSON.parse(jsonData) as StreamingExecutionData;\n\n      switch (data.type) {\n        case 'stdout':\n          if (callbacks.onStdout && data.text) {\n            await callbacks.onStdout({\n              text: data.text,\n              timestamp: data.timestamp || Date.now()\n            });\n          }\n          break;\n\n        case 'stderr':\n          if (callbacks.onStderr && data.text) {\n            await callbacks.onStderr({\n              text: data.text,\n              timestamp: data.timestamp || Date.now()\n            });\n          }\n          break;\n\n        case 'result':\n          if (callbacks.onResult) {\n            // Create a ResultImpl instance from the raw data\n            const result = new ResultImpl(data);\n            await callbacks.onResult(result);\n          }\n          break;\n\n        case 'error':\n          if (callbacks.onError) {\n            await callbacks.onError({\n              name: data.ename || 'Error',\n              message: data.evalue || 'Unknown error',\n              traceback: data.traceback || []\n            });\n          }\n          break;\n\n        case 'execution_complete':\n          // Signal completion - callbacks can handle cleanup if needed\n          break;\n      }\n    } catch (error) {\n      this.logError('parseExecutionResult', error);\n    }\n  }\n}\n", "import type {\n  ExposePortRequest,\n  PortCloseResult,\n  PortExposeResult,\n  PortListResult,\n  PortWatchRequest\n} from '@repo/shared';\nimport { BaseHttpClient } from './base-client';\n\n// Re-export for convenience\nexport type {\n  ExposePortRequest,\n  PortExposeResult,\n  PortCloseResult,\n  PortListResult\n};\n\n/**\n * Request interface for unexposing ports\n */\nexport interface UnexposePortRequest {\n  port: number;\n}\n\n/**\n * Client for port management and preview URL operations\n */\nexport class PortClient extends BaseHttpClient {\n  /**\n   * Expose a port and get a preview URL\n   * @param port - Port number to expose\n   * @param sessionId - The session ID for this operation\n   * @param name - Optional name for the port\n   */\n  async exposePort(\n    port: number,\n    sessionId: string,\n    name?: string\n  ): Promise<PortExposeResult> {\n    try {\n      const data = { port, sessionId, name };\n\n      const response = await this.post<PortExposeResult>(\n        '/api/expose-port',\n        data\n      );\n\n      this.logSuccess(\n        'Port exposed',\n        `${port} exposed at ${response.url}${name ? ` (${name})` : ''}`\n      );\n\n      return response;\n    } catch (error) {\n      this.logError('exposePort', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Unexpose a port and remove its preview URL\n   * @param port - Port number to unexpose\n   * @param sessionId - The session ID for this operation\n   */\n  async unexposePort(\n    port: number,\n    sessionId: string\n  ): Promise<PortCloseResult> {\n    try {\n      const url = `/api/exposed-ports/${port}?session=${encodeURIComponent(\n        sessionId\n      )}`;\n      const response = await this.delete<PortCloseResult>(url);\n\n      this.logSuccess('Port unexposed', `${port}`);\n      return response;\n    } catch (error) {\n      this.logError('unexposePort', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all currently exposed ports\n   * @param sessionId - The session ID for this operation\n   */\n  async getExposedPorts(sessionId: string): Promise<PortListResult> {\n    try {\n      const url = `/api/exposed-ports?session=${encodeURIComponent(sessionId)}`;\n      const response = await this.get<PortListResult>(url);\n\n      this.logSuccess(\n        'Exposed ports retrieved',\n        `${response.ports.length} ports exposed`\n      );\n\n      return response;\n    } catch (error) {\n      this.logError('getExposedPorts', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Watch a port for readiness via SSE stream\n   * @param request - Port watch configuration\n   * @returns SSE stream that emits PortWatchEvent objects\n   */\n  async watchPort(\n    request: PortWatchRequest\n  ): Promise<ReadableStream<Uint8Array>> {\n    try {\n      const stream = await this.doStreamFetch('/api/port-watch', request);\n      this.logSuccess('Port watch started', `port ${request.port}`);\n      return stream;\n    } catch (error) {\n      this.logError('watchPort', error);\n      throw error;\n    }\n  }\n}\n", "import type {\n  ProcessCleanupResult,\n  ProcessInfoResult,\n  ProcessKillResult,\n  ProcessListResult,\n  ProcessLogsResult,\n  ProcessStartResult,\n  StartProcessRequest\n} from '@repo/shared';\nimport { BaseHttpClient } from './base-client';\nimport type { HttpClientOptions } from './types';\n\n// Re-export for convenience\nexport type {\n  StartProcessRequest,\n  ProcessStartResult,\n  ProcessListResult,\n  ProcessInfoResult,\n  ProcessKillResult,\n  ProcessLogsResult,\n  ProcessCleanupResult\n};\n\n/**\n * Client for background process management\n */\nexport class ProcessClient extends BaseHttpClient {\n  /**\n   * Start a background process\n   * @param command - Command to execute as a background process\n   * @param sessionId - The session ID for this operation\n   * @param options - Optional settings (processId)\n   */\n  async startProcess(\n    command: string,\n    sessionId: string,\n    options?: {\n      processId?: string;\n      timeoutMs?: number;\n      env?: Record<string, string | undefined>;\n      cwd?: string;\n      encoding?: string;\n      autoCleanup?: boolean;\n    }\n  ): Promise<ProcessStartResult> {\n    try {\n      const data: StartProcessRequest = {\n        command,\n        sessionId,\n        ...(options?.processId !== undefined && {\n          processId: options.processId\n        }),\n        ...(options?.timeoutMs !== undefined && {\n          timeoutMs: options.timeoutMs\n        }),\n        ...(options?.env !== undefined && { env: options.env }),\n        ...(options?.cwd !== undefined && { cwd: options.cwd }),\n        ...(options?.encoding !== undefined && { encoding: options.encoding }),\n        ...(options?.autoCleanup !== undefined && {\n          autoCleanup: options.autoCleanup\n        })\n      };\n\n      const response = await this.post<ProcessStartResult>(\n        '/api/process/start',\n        data\n      );\n\n      this.logSuccess(\n        'Process started',\n        `${command} (ID: ${response.processId})`\n      );\n\n      return response;\n    } catch (error) {\n      this.logError('startProcess', error);\n      throw error;\n    }\n  }\n\n  /**\n   * List all processes (sandbox-scoped, not session-scoped)\n   */\n  async listProcesses(): Promise<ProcessListResult> {\n    try {\n      const url = `/api/process/list`;\n      const response = await this.get<ProcessListResult>(url);\n\n      this.logSuccess(\n        'Processes listed',\n        `${response.processes.length} processes`\n      );\n      return response;\n    } catch (error) {\n      this.logError('listProcesses', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get information about a specific process (sandbox-scoped, not session-scoped)\n   * @param processId - ID of the process to retrieve\n   */\n  async getProcess(processId: string): Promise<ProcessInfoResult> {\n    try {\n      const url = `/api/process/${processId}`;\n      const response = await this.get<ProcessInfoResult>(url);\n\n      this.logSuccess('Process retrieved', `ID: ${processId}`);\n      return response;\n    } catch (error) {\n      this.logError('getProcess', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Kill a specific process (sandbox-scoped, not session-scoped)\n   * @param processId - ID of the process to kill\n   */\n  async killProcess(processId: string): Promise<ProcessKillResult> {\n    try {\n      const url = `/api/process/${processId}`;\n      const response = await this.delete<ProcessKillResult>(url);\n\n      this.logSuccess('Process killed', `ID: ${processId}`);\n      return response;\n    } catch (error) {\n      this.logError('killProcess', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Kill all running processes (sandbox-scoped, not session-scoped)\n   */\n  async killAllProcesses(): Promise<ProcessCleanupResult> {\n    try {\n      const url = `/api/process/kill-all`;\n      const response = await this.delete<ProcessCleanupResult>(url);\n\n      this.logSuccess(\n        'All processes killed',\n        `${response.cleanedCount} processes terminated`\n      );\n\n      return response;\n    } catch (error) {\n      this.logError('killAllProcesses', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get logs from a specific process (sandbox-scoped, not session-scoped)\n   * @param processId - ID of the process to get logs from\n   */\n  async getProcessLogs(processId: string): Promise<ProcessLogsResult> {\n    try {\n      const url = `/api/process/${processId}/logs`;\n      const response = await this.get<ProcessLogsResult>(url);\n\n      this.logSuccess(\n        'Process logs retrieved',\n        `ID: ${processId}, stdout: ${response.stdout.length} chars, stderr: ${response.stderr.length} chars`\n      );\n\n      return response;\n    } catch (error) {\n      this.logError('getProcessLogs', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Stream logs from a specific process (sandbox-scoped, not session-scoped)\n   * @param processId - ID of the process to stream logs from\n   */\n  async streamProcessLogs(\n    processId: string\n  ): Promise<ReadableStream<Uint8Array>> {\n    try {\n      const url = `/api/process/${processId}/stream`;\n      // Use doStreamFetch with GET method (process log streaming is GET)\n      const stream = await this.doStreamFetch(url, undefined, 'GET');\n\n      this.logSuccess('Process log stream started', `ID: ${processId}`);\n\n      return stream;\n    } catch (error) {\n      this.logError('streamProcessLogs', error);\n      throw error;\n    }\n  }\n}\n", "import { BaseHttpClient } from './base-client';\nimport type { BaseApiResponse, HttpClientOptions } from './types';\n\n/**\n * Response interface for ping operations\n */\nexport interface PingResponse extends BaseApiResponse {\n  message: string;\n  uptime?: number;\n}\n\n/**\n * Response interface for getting available commands\n */\nexport interface CommandsResponse extends BaseApiResponse {\n  availableCommands: string[];\n  count: number;\n}\n\n/**\n * Response interface for getting container version\n */\nexport interface VersionResponse extends BaseApiResponse {\n  version: string;\n}\n\n/**\n * Request interface for creating sessions\n */\nexport interface CreateSessionRequest {\n  id: string;\n  env?: Record<string, string | undefined>;\n  cwd?: string;\n}\n\n/**\n * Response interface for creating sessions\n */\nexport interface CreateSessionResponse extends BaseApiResponse {\n  id: string;\n  message: string;\n}\n\n/**\n * Request interface for deleting sessions\n */\nexport interface DeleteSessionRequest {\n  sessionId: string;\n}\n\n/**\n * Response interface for deleting sessions\n */\nexport interface DeleteSessionResponse extends BaseApiResponse {\n  sessionId: string;\n}\n\n/**\n * Client for health checks and utility operations\n */\nexport class UtilityClient extends BaseHttpClient {\n  /**\n   * Ping the sandbox to check if it's responsive\n   */\n  async ping(): Promise<string> {\n    try {\n      const response = await this.get<PingResponse>('/api/ping');\n\n      this.logSuccess('Ping successful', response.message);\n      return response.message;\n    } catch (error) {\n      this.logError('ping', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get list of available commands in the sandbox environment\n   */\n  async getCommands(): Promise<string[]> {\n    try {\n      const response = await this.get<CommandsResponse>('/api/commands');\n\n      this.logSuccess(\n        'Commands retrieved',\n        `${response.count} commands available`\n      );\n\n      return response.availableCommands;\n    } catch (error) {\n      this.logError('getCommands', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a new execution session\n   * @param options - Session configuration (id, env, cwd)\n   */\n  async createSession(\n    options: CreateSessionRequest\n  ): Promise<CreateSessionResponse> {\n    try {\n      const response = await this.post<CreateSessionResponse>(\n        '/api/session/create',\n        options\n      );\n\n      this.logSuccess('Session created', `ID: ${options.id}`);\n      return response;\n    } catch (error) {\n      this.logError('createSession', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete an execution session\n   * @param sessionId - Session ID to delete\n   */\n  async deleteSession(sessionId: string): Promise<DeleteSessionResponse> {\n    try {\n      const response = await this.post<DeleteSessionResponse>(\n        '/api/session/delete',\n        { sessionId }\n      );\n\n      this.logSuccess('Session deleted', `ID: ${sessionId}`);\n      return response;\n    } catch (error) {\n      this.logError('deleteSession', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get the container version\n   * Returns the version embedded in the Docker image during build\n   */\n  async getVersion(): Promise<string> {\n    try {\n      const response = await this.get<VersionResponse>('/api/version');\n\n      this.logSuccess('Version retrieved', response.version);\n      return response.version;\n    } catch (error) {\n      // If version endpoint doesn't exist (old container), return 'unknown'\n      // This allows for backward compatibility\n      this.logger.debug(\n        'Failed to get container version (may be old container)',\n        { error }\n      );\n      return 'unknown';\n    }\n  }\n}\n", "import { CommandClient } from './command-client';\nimport { FileClient } from './file-client';\nimport { GitClient } from './git-client';\nimport { InterpreterClient } from './interpreter-client';\nimport { PortClient } from './port-client';\nimport { ProcessClient } from './process-client';\nimport {\n  createTransport,\n  type ITransport,\n  type TransportMode\n} from './transport';\nimport type { HttpClientOptions } from './types';\nimport { UtilityClient } from './utility-client';\n\n/**\n * Main sandbox client that composes all domain-specific clients\n * Provides organized access to all sandbox functionality\n *\n * Supports two transport modes:\n * - HTTP (default): Each request is a separate HTTP call\n * - WebSocket: All requests multiplexed over a single connection\n *\n * WebSocket mode reduces sub-request count when running inside Workers/Durable Objects.\n */\nexport class SandboxClient {\n  public readonly commands: CommandClient;\n  public readonly files: FileClient;\n  public readonly processes: ProcessClient;\n  public readonly ports: PortClient;\n  public readonly git: GitClient;\n  public readonly interpreter: InterpreterClient;\n  public readonly utils: UtilityClient;\n\n  private transport: ITransport | null = null;\n\n  constructor(options: HttpClientOptions) {\n    // Create shared transport if WebSocket mode is enabled\n    if (options.transportMode === 'websocket' && options.wsUrl) {\n      this.transport = createTransport({\n        mode: 'websocket',\n        wsUrl: options.wsUrl,\n        baseUrl: options.baseUrl,\n        logger: options.logger,\n        stub: options.stub,\n        port: options.port\n      });\n    }\n\n    // Ensure baseUrl is provided for all clients\n    const clientOptions: HttpClientOptions = {\n      baseUrl: 'http://localhost:3000',\n      ...options,\n      // Share transport across all clients\n      transport: this.transport ?? options.transport\n    };\n\n    // Initialize all domain clients with shared options\n    this.commands = new CommandClient(clientOptions);\n    this.files = new FileClient(clientOptions);\n    this.processes = new ProcessClient(clientOptions);\n    this.ports = new PortClient(clientOptions);\n    this.git = new GitClient(clientOptions);\n    this.interpreter = new InterpreterClient(clientOptions);\n    this.utils = new UtilityClient(clientOptions);\n  }\n\n  /**\n   * Get the current transport mode\n   */\n  getTransportMode(): TransportMode {\n    return this.transport?.getMode() ?? 'http';\n  }\n\n  /**\n   * Check if WebSocket is connected (only relevant in WebSocket mode)\n   */\n  isWebSocketConnected(): boolean {\n    return this.transport?.isConnected() ?? false;\n  }\n\n  /**\n   * Connect WebSocket transport (no-op in HTTP mode)\n   * Called automatically on first request, but can be called explicitly\n   * to establish connection upfront.\n   */\n  async connect(): Promise<void> {\n    if (this.transport) {\n      await this.transport.connect();\n    }\n  }\n\n  /**\n   * Disconnect WebSocket transport (no-op in HTTP mode)\n   * Should be called when the sandbox is destroyed.\n   */\n  disconnect(): void {\n    if (this.transport) {\n      this.transport.disconnect();\n    }\n  }\n}\n", "/**\n * Security utilities for URL construction and input validation\n *\n * This module contains critical security functions to prevent:\n * - URL injection attacks\n * - SSRF (Server-Side Request Forgery) attacks\n * - DNS rebinding attacks\n * - Host header injection\n * - Open redirect vulnerabilities\n */\n\nexport class SecurityError extends Error {\n  constructor(\n    message: string,\n    public readonly code?: string\n  ) {\n    super(message);\n    this.name = 'SecurityError';\n  }\n}\n\n/**\n * Validates port numbers for sandbox services\n * Only allows non-system ports to prevent conflicts and security issues\n */\nexport function validatePort(port: number): boolean {\n  // Must be a valid integer\n  if (!Number.isInteger(port)) {\n    return false;\n  }\n\n  // Only allow non-system ports (1024-65535)\n  if (port < 1024 || port > 65535) {\n    return false;\n  }\n\n  // Exclude ports reserved by our system\n  const reservedPorts = [\n    3000, // Control plane port\n    8787 // Common wrangler dev port\n  ];\n\n  if (reservedPorts.includes(port)) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Sanitizes and validates sandbox IDs for DNS compliance and security\n * Only enforces critical requirements - allows maximum developer flexibility\n */\nexport function sanitizeSandboxId(id: string): string {\n  // Basic validation: not empty, reasonable length limit (DNS subdomain limit is 63 chars)\n  if (!id || id.length > 63) {\n    throw new SecurityError(\n      'Sandbox ID must be 1-63 characters long.',\n      'INVALID_SANDBOX_ID_LENGTH'\n    );\n  }\n\n  // DNS compliance: cannot start or end with hyphens (RFC requirement)\n  if (id.startsWith('-') || id.endsWith('-')) {\n    throw new SecurityError(\n      'Sandbox ID cannot start or end with hyphens (DNS requirement).',\n      'INVALID_SANDBOX_ID_HYPHENS'\n    );\n  }\n\n  // Prevent reserved names that cause technical conflicts\n  const reservedNames = [\n    'www',\n    'api',\n    'admin',\n    'root',\n    'system',\n    'cloudflare',\n    'workers'\n  ];\n\n  const lowerCaseId = id.toLowerCase();\n  if (reservedNames.includes(lowerCaseId)) {\n    throw new SecurityError(\n      `Reserved sandbox ID '${id}' is not allowed.`,\n      'RESERVED_SANDBOX_ID'\n    );\n  }\n\n  return id;\n}\n\n/**\n * Validates language for code interpreter\n * Only allows supported languages\n */\nexport function validateLanguage(language: string | undefined): void {\n  if (!language) {\n    return; // undefined is valid, will default to python\n  }\n\n  const supportedLanguages = [\n    'python',\n    'python3',\n    'javascript',\n    'js',\n    'node',\n    'typescript',\n    'ts'\n  ];\n  const normalized = language.toLowerCase();\n\n  if (!supportedLanguages.includes(normalized)) {\n    throw new SecurityError(\n      `Unsupported language '${language}'. Supported languages: python, javascript, typescript`,\n      'INVALID_LANGUAGE'\n    );\n  }\n}\n", "import {\n  type CodeContext,\n  type CreateContextOptions,\n  Execution,\n  type ExecutionError,\n  type OutputMessage,\n  type Result,\n  ResultImpl,\n  type RunCodeOptions\n} from '@repo/shared';\nimport type { InterpreterClient } from './clients/interpreter-client.js';\nimport type { Sandbox } from './sandbox.js';\nimport { validateLanguage } from './security.js';\n\nexport class CodeInterpreter {\n  private interpreterClient: InterpreterClient;\n  private contexts = new Map<string, CodeContext>();\n\n  constructor(sandbox: Sandbox) {\n    // In init-testing architecture, client is a SandboxClient with an interpreter property\n    this.interpreterClient = (sandbox.client as any)\n      .interpreter as InterpreterClient;\n  }\n\n  /**\n   * Create a new code execution context\n   */\n  async createCodeContext(\n    options: CreateContextOptions = {}\n  ): Promise<CodeContext> {\n    // Validate language before sending to container\n    validateLanguage(options.language);\n\n    const context = await this.interpreterClient.createCodeContext(options);\n    this.contexts.set(context.id, context);\n    return context;\n  }\n\n  /**\n   * Run code with optional context\n   */\n  async runCode(\n    code: string,\n    options: RunCodeOptions = {}\n  ): Promise<Execution> {\n    // Get or create context\n    let context = options.context;\n    if (!context) {\n      // Try to find or create a default context for the language\n      const language = options.language || 'python';\n      context = await this.getOrCreateDefaultContext(language);\n    }\n\n    // Create execution object to collect results\n    const execution = new Execution(code, context);\n\n    // Stream execution\n    await this.interpreterClient.runCodeStream(\n      context.id,\n      code,\n      options.language,\n      {\n        onStdout: (output: OutputMessage) => {\n          execution.logs.stdout.push(output.text);\n          if (options.onStdout) return options.onStdout(output);\n        },\n        onStderr: (output: OutputMessage) => {\n          execution.logs.stderr.push(output.text);\n          if (options.onStderr) return options.onStderr(output);\n        },\n        onResult: async (result: Result) => {\n          execution.results.push(new ResultImpl(result) as any);\n          if (options.onResult) return options.onResult(result);\n        },\n        onError: (error: ExecutionError) => {\n          execution.error = error;\n          if (options.onError) return options.onError(error);\n        }\n      }\n    );\n\n    return execution;\n  }\n\n  /**\n   * Run code and return a streaming response\n   */\n  async runCodeStream(\n    code: string,\n    options: RunCodeOptions = {}\n  ): Promise<ReadableStream> {\n    // Get or create context\n    let context = options.context;\n    if (!context) {\n      const language = options.language || 'python';\n      context = await this.getOrCreateDefaultContext(language);\n    }\n\n    // Use streamCode which handles both HTTP and WebSocket streaming\n    return this.interpreterClient.streamCode(\n      context.id,\n      code,\n      options.language\n    );\n  }\n\n  /**\n   * List all code contexts\n   */\n  async listCodeContexts(): Promise<CodeContext[]> {\n    const contexts = await this.interpreterClient.listCodeContexts();\n\n    // Update local cache\n    for (const context of contexts) {\n      this.contexts.set(context.id, context);\n    }\n\n    return contexts;\n  }\n\n  /**\n   * Delete a code context\n   */\n  async deleteCodeContext(contextId: string): Promise<void> {\n    await this.interpreterClient.deleteCodeContext(contextId);\n    this.contexts.delete(contextId);\n  }\n\n  private async getOrCreateDefaultContext(\n    language: 'python' | 'javascript' | 'typescript'\n  ): Promise<CodeContext> {\n    // Check if we have a cached context for this language\n    for (const context of this.contexts.values()) {\n      if (context.language === language) {\n        return context;\n      }\n    }\n\n    // Create new default context\n    return this.createCodeContext({ language });\n  }\n}\n", "import { switchPort } from '@cloudflare/containers';\nimport { createLogger, type LogContext, TraceContext } from '@repo/shared';\nimport { getSandbox, type Sandbox } from './sandbox';\nimport { sanitizeSandboxId, validatePort } from './security';\n\nexport interface SandboxEnv<T extends Sandbox<any> = Sandbox<any>> {\n  Sandbox: DurableObjectNamespace<T>;\n}\n\nexport interface RouteInfo {\n  port: number;\n  sandboxId: string;\n  path: string;\n  token: string;\n}\n\nexport async function proxyToSandbox<\n  T extends Sandbox<any>,\n  E extends SandboxEnv<T>\n>(request: Request, env: E): Promise<Response | null> {\n  // Create logger context for this request\n  const traceId =\n    TraceContext.fromHeaders(request.headers) || TraceContext.generate();\n  const logger = createLogger({\n    component: 'sandbox-do',\n    traceId,\n    operation: 'proxy'\n  });\n\n  try {\n    const url = new URL(request.url);\n    const routeInfo = extractSandboxRoute(url);\n\n    if (!routeInfo) {\n      return null; // Not a request to an exposed container port\n    }\n\n    const { sandboxId, port, path, token } = routeInfo;\n    // Preview URLs always use normalized (lowercase) IDs\n    const sandbox = getSandbox(env.Sandbox, sandboxId, { normalizeId: true });\n\n    // Critical security check: Validate token (mandatory for all user ports)\n    // Skip check for control plane port 3000\n    if (port !== 3000) {\n      // Validate the token matches the port\n      const isValidToken = await sandbox.validatePortToken(port, token);\n      if (!isValidToken) {\n        logger.warn('Invalid token access blocked', {\n          port,\n          sandboxId,\n          path,\n          hostname: url.hostname,\n          url: request.url,\n          method: request.method,\n          userAgent: request.headers.get('User-Agent') || 'unknown'\n        });\n\n        return new Response(\n          JSON.stringify({\n            error: `Access denied: Invalid token or port not exposed`,\n            code: 'INVALID_TOKEN'\n          }),\n          {\n            status: 404,\n            headers: {\n              'Content-Type': 'application/json'\n            }\n          }\n        );\n      }\n    }\n\n    // Detect WebSocket upgrade request\n    const upgradeHeader = request.headers.get('Upgrade');\n    if (upgradeHeader?.toLowerCase() === 'websocket') {\n      // WebSocket path: Must use fetch() not containerFetch()\n      // This bypasses JSRPC serialization boundary which cannot handle WebSocket upgrades\n      return await sandbox.fetch(switchPort(request, port));\n    }\n\n    // Build proxy request with proper headers\n    let proxyUrl: string;\n\n    // Route based on the target port\n    if (port !== 3000) {\n      // Route directly to user's service on the specified port\n      proxyUrl = `http://localhost:${port}${path}${url.search}`;\n    } else {\n      // Port 3000 is our control plane - route normally\n      proxyUrl = `http://localhost:3000${path}${url.search}`;\n    }\n\n    const proxyRequest = new Request(proxyUrl, {\n      method: request.method,\n      headers: {\n        ...Object.fromEntries(request.headers),\n        'X-Original-URL': request.url,\n        'X-Forwarded-Host': url.hostname,\n        'X-Forwarded-Proto': url.protocol.replace(':', ''),\n        'X-Sandbox-Name': sandboxId // Pass the friendly name\n      },\n      body: request.body,\n      // @ts-expect-error - duplex required for body streaming in modern runtimes\n      duplex: 'half'\n    });\n\n    return await sandbox.containerFetch(proxyRequest, port);\n  } catch (error) {\n    logger.error(\n      'Proxy routing error',\n      error instanceof Error ? error : new Error(String(error))\n    );\n    return new Response('Proxy routing error', { status: 500 });\n  }\n}\n\nfunction extractSandboxRoute(url: URL): RouteInfo | null {\n  // URL format: {port}-{sandboxId}-{token}.{domain}\n  // Tokens are [a-z0-9_]+, so we split at the last hyphen to handle sandboxIds with hyphens (UUIDs)\n  const dotIndex = url.hostname.indexOf('.');\n  if (dotIndex === -1) {\n    return null;\n  }\n\n  const subdomain = url.hostname.slice(0, dotIndex);\n  const domain = url.hostname.slice(dotIndex + 1);\n\n  // Extract port (digits at start followed by hyphen)\n  const firstHyphen = subdomain.indexOf('-');\n  if (firstHyphen === -1) {\n    return null;\n  }\n\n  const portStr = subdomain.slice(0, firstHyphen);\n  if (!/^\\d{4,5}$/.test(portStr)) {\n    return null;\n  }\n\n  const port = parseInt(portStr, 10);\n  if (!validatePort(port)) {\n    return null;\n  }\n\n  // Extract token (last hyphen-delimited segment) and sandboxId (everything between port and token)\n  const rest = subdomain.slice(firstHyphen + 1);\n  const lastHyphen = rest.lastIndexOf('-');\n  if (lastHyphen === -1) {\n    return null;\n  }\n\n  const sandboxId = rest.slice(0, lastHyphen);\n  const token = rest.slice(lastHyphen + 1);\n\n  // Validate token format (no hyphens allowed)\n  if (!/^[a-z0-9_]+$/.test(token) || token.length === 0 || token.length > 63) {\n    return null;\n  }\n\n  // Validate and sanitize sandboxId\n  if (sandboxId.length === 0 || sandboxId.length > 63) {\n    return null;\n  }\n\n  let sanitizedSandboxId: string;\n  try {\n    sanitizedSandboxId = sanitizeSandboxId(sandboxId);\n  } catch {\n    return null;\n  }\n\n  return {\n    port,\n    sandboxId: sanitizedSandboxId,\n    path: url.pathname || '/',\n    token\n  };\n}\n\nexport function isLocalhostPattern(hostname: string): boolean {\n  // Handle IPv6 addresses in brackets (with or without port)\n  if (hostname.startsWith('[')) {\n    if (hostname.includes(']:')) {\n      // [::1]:port format\n      const ipv6Part = hostname.substring(0, hostname.indexOf(']:') + 1);\n      return ipv6Part === '[::1]';\n    } else {\n      // [::1] format without port\n      return hostname === '[::1]';\n    }\n  }\n\n  // Handle bare IPv6 without brackets\n  if (hostname === '::1') {\n    return true;\n  }\n\n  // For IPv4 and regular hostnames, split on colon to remove port\n  const hostPart = hostname.split(':')[0];\n\n  return (\n    hostPart === 'localhost' ||\n    hostPart === '127.0.0.1' ||\n    hostPart === '0.0.0.0'\n  );\n}\n", "/**\n * Server-Sent Events (SSE) parser for streaming responses\n * Converts ReadableStream<Uint8Array> to typed AsyncIterable<T>\n */\n\n/**\n * Parse a ReadableStream of SSE events into typed AsyncIterable\n * @param stream - The ReadableStream from fetch response\n * @param signal - Optional AbortSignal for cancellation\n */\nexport async function* parseSSEStream<T>(\n  stream: ReadableStream<Uint8Array>,\n  signal?: AbortSignal\n): AsyncIterable<T> {\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  let buffer = '';\n\n  try {\n    while (true) {\n      // Check for cancellation\n      if (signal?.aborted) {\n        throw new Error('Operation was aborted');\n      }\n\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      // Decode chunk and add to buffer\n      buffer += decoder.decode(value, { stream: true });\n\n      // Process complete SSE events in buffer\n      const lines = buffer.split('\\n');\n\n      // Keep the last incomplete line in buffer\n      buffer = lines.pop() || '';\n\n      for (const line of lines) {\n        // Skip empty lines\n        if (line.trim() === '') continue;\n\n        // Process SSE data lines\n        if (line.startsWith('data: ')) {\n          const data = line.substring(6);\n\n          // Skip [DONE] markers or empty data\n          if (data === '[DONE]' || data.trim() === '') continue;\n\n          try {\n            const event = JSON.parse(data) as T;\n            yield event;\n          } catch {\n            // Skip invalid JSON events and continue processing\n          }\n        }\n        // Handle other SSE fields if needed (event:, id:, retry:)\n        // For now, we only care about data: lines\n      }\n    }\n\n    // Process any remaining data in buffer\n    if (buffer.trim() && buffer.startsWith('data: ')) {\n      const data = buffer.substring(6);\n      if (data !== '[DONE]' && data.trim()) {\n        try {\n          const event = JSON.parse(data) as T;\n          yield event;\n        } catch {\n          // Skip invalid JSON in final event\n        }\n      }\n    }\n  } finally {\n    // Clean up resources\n    try {\n      await reader.cancel();\n    } catch {}\n    reader.releaseLock();\n  }\n}\n\n/**\n * Helper to convert a Response with SSE stream directly to AsyncIterable\n * @param response - Response object with SSE stream\n * @param signal - Optional AbortSignal for cancellation\n */\nexport async function* responseToAsyncIterable<T>(\n  response: Response,\n  signal?: AbortSignal\n): AsyncIterable<T> {\n  if (!response.ok) {\n    throw new Error(\n      `Response not ok: ${response.status} ${response.statusText}`\n    );\n  }\n\n  if (!response.body) {\n    throw new Error('No response body');\n  }\n\n  yield* parseSSEStream<T>(response.body, signal);\n}\n\n/**\n * Create an SSE-formatted ReadableStream from an AsyncIterable\n * (Useful for Worker endpoints that need to forward AsyncIterable as SSE)\n * @param events - AsyncIterable of events\n * @param options - Stream options\n */\nexport function asyncIterableToSSEStream<T>(\n  events: AsyncIterable<T>,\n  options?: {\n    signal?: AbortSignal;\n    serialize?: (event: T) => string;\n  }\n): ReadableStream<Uint8Array> {\n  const encoder = new TextEncoder();\n  const serialize = options?.serialize || JSON.stringify;\n\n  return new ReadableStream({\n    async start(controller) {\n      try {\n        for await (const event of events) {\n          if (options?.signal?.aborted) {\n            controller.error(new Error('Operation was aborted'));\n            break;\n          }\n\n          const data = serialize(event);\n          const sseEvent = `data: ${data}\\n\\n`;\n          controller.enqueue(encoder.encode(sseEvent));\n        }\n\n        // Send completion marker\n        controller.enqueue(encoder.encode('data: [DONE]\\n\\n'));\n      } catch (error) {\n        controller.error(error);\n      } finally {\n        controller.close();\n      }\n    },\n\n    cancel() {\n      // Handle stream cancellation\n    }\n  });\n}\n", "/**\n * Bucket mounting error classes\n *\n * These are SDK-side validation errors that follow the same pattern as SecurityError.\n * They are thrown before any container interaction occurs.\n */\n\nimport { ErrorCode } from '@repo/shared/errors';\n\n/**\n * Base error for bucket mounting operations\n */\nexport class BucketMountError extends Error {\n  public readonly code: ErrorCode;\n\n  constructor(message: string, code: ErrorCode = ErrorCode.BUCKET_MOUNT_ERROR) {\n    super(message);\n    this.name = 'BucketMountError';\n    this.code = code;\n  }\n}\n\n/**\n * Thrown when S3FS mount command fails\n */\nexport class S3FSMountError extends BucketMountError {\n  constructor(message: string) {\n    super(message, ErrorCode.S3FS_MOUNT_ERROR);\n    this.name = 'S3FSMountError';\n  }\n}\n\n/**\n * Thrown when no credentials found in environment\n */\nexport class MissingCredentialsError extends BucketMountError {\n  constructor(message: string) {\n    super(message, ErrorCode.MISSING_CREDENTIALS);\n    this.name = 'MissingCredentialsError';\n  }\n}\n\n/**\n * Thrown when bucket name, mount path, or options are invalid\n */\nexport class InvalidMountConfigError extends BucketMountError {\n  constructor(message: string) {\n    super(message, ErrorCode.INVALID_MOUNT_CONFIG);\n    this.name = 'InvalidMountConfigError';\n  }\n}\n", "import type { BucketCredentials, MountBucketOptions } from '@repo/shared';\nimport { MissingCredentialsError } from './errors';\n\n/**\n * Detect credentials for bucket mounting from environment variables\n * Priority order:\n * 1. Explicit options.credentials\n * 2. Standard AWS env vars: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY\n * 3. Error: no credentials found\n *\n * @param options - Mount options\n * @param envVars - Environment variables\n * @returns Detected credentials\n * @throws MissingCredentialsError if no credentials found\n */\nexport function detectCredentials(\n  options: MountBucketOptions,\n  envVars: Record<string, string | undefined>\n): BucketCredentials {\n  // Priority 1: Explicit credentials in options\n  if (options.credentials) {\n    return options.credentials;\n  }\n\n  // Priority 2: Standard AWS env vars\n  const awsAccessKeyId = envVars.AWS_ACCESS_KEY_ID;\n  const awsSecretAccessKey = envVars.AWS_SECRET_ACCESS_KEY;\n\n  if (awsAccessKeyId && awsSecretAccessKey) {\n    return {\n      accessKeyId: awsAccessKeyId,\n      secretAccessKey: awsSecretAccessKey\n    };\n  }\n\n  // No credentials found - throw error with helpful message\n  throw new MissingCredentialsError(\n    `No credentials found. Set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY ` +\n      `environment variables, or pass explicit credentials in options.`\n  );\n}\n", "/**\n * Provider detection and s3fs flag configuration\n *\n * Based on s3fs-fuse documentation:\n * https://github.com/s3fs-fuse/s3fs-fuse/wiki/Non-Amazon-S3\n */\n\nimport type { BucketProvider } from '@repo/shared';\n\n/**\n * Detect provider from endpoint URL using pattern matching\n */\nexport function detectProviderFromUrl(endpoint: string): BucketProvider | null {\n  try {\n    const url = new URL(endpoint);\n    const hostname = url.hostname.toLowerCase();\n\n    if (hostname.endsWith('.r2.cloudflarestorage.com')) {\n      return 'r2';\n    }\n\n    // Match AWS S3: *.amazonaws.com or s3.amazonaws.com\n    if (\n      hostname.endsWith('.amazonaws.com') ||\n      hostname === 's3.amazonaws.com'\n    ) {\n      return 's3';\n    }\n\n    if (hostname === 'storage.googleapis.com') {\n      return 'gcs';\n    }\n\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Get s3fs flags for a given provider\n *\n * Based on s3fs-fuse wiki recommendations:\n * https://github.com/s3fs-fuse/s3fs-fuse/wiki/Non-Amazon-S3\n */\nexport function getProviderFlags(provider: BucketProvider | null): string[] {\n  if (!provider) {\n    return ['use_path_request_style'];\n  }\n\n  switch (provider) {\n    case 'r2':\n      return ['nomixupload'];\n\n    case 's3':\n      return [];\n\n    case 'gcs':\n      return [];\n\n    default:\n      return ['use_path_request_style'];\n  }\n}\n\n/**\n * Resolve s3fs options by combining provider defaults with user overrides\n */\nexport function resolveS3fsOptions(\n  provider: BucketProvider | null,\n  userOptions?: string[]\n): string[] {\n  const providerFlags = getProviderFlags(provider);\n\n  if (!userOptions || userOptions.length === 0) {\n    return providerFlags;\n  }\n\n  // Merge provider flags with user options\n  // User options take precedence (come last in the array)\n  const allFlags = [...providerFlags, ...userOptions];\n\n  // Deduplicate flags (keep last occurrence)\n  const flagMap = new Map<string, string>();\n\n  for (const flag of allFlags) {\n    // Split on '=' to get the flag name\n    const [flagName] = flag.split('=');\n    flagMap.set(flagName, flag);\n  }\n\n  return Array.from(flagMap.values());\n}\n", "import { InvalidMountConfigError } from './errors';\n\nexport function validatePrefix(prefix: string): void {\n  if (!prefix.startsWith('/')) {\n    throw new InvalidMountConfigError(\n      `Prefix must start with '/': \"${prefix}\"`\n    );\n  }\n}\n\nexport function validateBucketName(bucket: string, mountPath: string): void {\n  if (bucket.includes(':')) {\n    const [bucketName, prefixPart] = bucket.split(':');\n    throw new InvalidMountConfigError(\n      `Bucket name cannot contain ':'. To mount a prefix, use the 'prefix' option:\\n` +\n        `  mountBucket('${bucketName}', '${mountPath}', { ...options, prefix: '${prefixPart}' })`\n    );\n  }\n\n  const bucketNameRegex = /^[a-z0-9]([a-z0-9.-]{0,61}[a-z0-9])?$/;\n  if (!bucketNameRegex.test(bucket)) {\n    throw new InvalidMountConfigError(\n      `Invalid bucket name: \"${bucket}\". Bucket names must be 3-63 characters, ` +\n        `lowercase alphanumeric, dots, or hyphens, and cannot start/end with dots or hyphens.`\n    );\n  }\n}\n\n/**\n * Builds the s3fs source string from bucket name and optional prefix.\n * Format: \"bucket\" or \"bucket:/prefix/\" for subdirectory mounts.\n *\n * @param bucket - The bucket name\n * @param prefix - Optional prefix/subdirectory path\n * @returns The s3fs source string\n */\nexport function buildS3fsSource(bucket: string, prefix?: string): string {\n  return prefix ? `${bucket}:${prefix}` : bucket;\n}\n", "/**\n * SDK version - automatically synchronized with package.json by Changesets\n * This file is auto-updated by .github/changeset-version.ts during releases\n * DO NOT EDIT MANUALLY - Changes will be overwritten on the next version bump\n */\nexport const SDK_VERSION = '0.7.0';\n", "import { Container, getContainer, switchPort } from '@cloudflare/containers';\nimport type {\n  BucketCredentials,\n  BucketProvider,\n  CodeContext,\n  CreateContextOptions,\n  ExecEvent,\n  ExecOptions,\n  ExecResult,\n  ExecutionResult,\n  ExecutionSession,\n  ISandbox,\n  LogEvent,\n  MountBucketOptions,\n  PortWatchEvent,\n  Process,\n  ProcessOptions,\n  ProcessStatus,\n  RunCodeOptions,\n  SandboxOptions,\n  SessionOptions,\n  StreamOptions,\n  WaitForExitResult,\n  WaitForLogResult,\n  WaitForPortOptions\n} from '@repo/shared';\nimport {\n  createLogger,\n  filterEnvVars,\n  getEnvString,\n  isTerminalStatus,\n  partitionEnvVars,\n  type SessionDeleteResult,\n  shellEscape,\n  TraceContext\n} from '@repo/shared';\nimport { type ExecuteResponse, SandboxClient } from './clients';\nimport type { ErrorResponse } from './errors';\nimport {\n  CustomDomainRequiredError,\n  ErrorCode,\n  ProcessExitedBeforeReadyError,\n  ProcessReadyTimeoutError,\n  SessionAlreadyExistsError\n} from './errors';\nimport { CodeInterpreter } from './interpreter';\nimport { isLocalhostPattern } from './request-handler';\nimport { SecurityError, sanitizeSandboxId, validatePort } from './security';\nimport { parseSSEStream } from './sse-parser';\nimport {\n  buildS3fsSource,\n  detectCredentials,\n  detectProviderFromUrl,\n  resolveS3fsOptions,\n  validateBucketName,\n  validatePrefix\n} from './storage-mount';\nimport {\n  InvalidMountConfigError,\n  S3FSMountError\n} from './storage-mount/errors';\nimport type { MountInfo } from './storage-mount/types';\nimport { SDK_VERSION } from './version';\n\nexport function getSandbox<T extends Sandbox<any>>(\n  ns: DurableObjectNamespace<T>,\n  id: string,\n  options?: SandboxOptions\n): T {\n  const sanitizedId = sanitizeSandboxId(id);\n  const effectiveId = options?.normalizeId\n    ? sanitizedId.toLowerCase()\n    : sanitizedId;\n\n  const hasUppercase = /[A-Z]/.test(sanitizedId);\n  if (!options?.normalizeId && hasUppercase) {\n    const logger = createLogger({ component: 'sandbox-do' });\n    logger.warn(\n      `Sandbox ID \"${sanitizedId}\" contains uppercase letters, which causes issues with preview URLs (hostnames are case-insensitive). ` +\n        `normalizeId will default to true in a future version to prevent this. ` +\n        `Use lowercase IDs or pass { normalizeId: true } to prepare.`\n    );\n  }\n\n  const stub = getContainer(ns, effectiveId);\n\n  stub.setSandboxName?.(effectiveId, options?.normalizeId);\n\n  if (options?.baseUrl) {\n    stub.setBaseUrl(options.baseUrl);\n  }\n\n  if (options?.sleepAfter !== undefined) {\n    stub.setSleepAfter(options.sleepAfter);\n  }\n\n  if (options?.keepAlive !== undefined) {\n    stub.setKeepAlive(options.keepAlive);\n  }\n\n  if (options?.containerTimeouts) {\n    stub.setContainerTimeouts(options.containerTimeouts);\n  }\n\n  return Object.assign(stub, {\n    wsConnect: connect(stub)\n  }) as T;\n}\n\nexport function connect(stub: {\n  fetch: (request: Request) => Promise<Response>;\n}) {\n  return async (request: Request, port: number) => {\n    if (!validatePort(port)) {\n      throw new SecurityError(\n        `Invalid or restricted port: ${port}. Ports must be in range 1024-65535 and not reserved.`\n      );\n    }\n    const portSwitchedRequest = switchPort(request, port);\n    return await stub.fetch(portSwitchedRequest);\n  };\n}\n\nexport class Sandbox<Env = unknown> extends Container<Env> implements ISandbox {\n  defaultPort = 3000; // Default port for the container's Bun server\n  sleepAfter: string | number = '10m'; // Sleep the sandbox if no requests are made in this timeframe\n\n  client: SandboxClient;\n  private codeInterpreter: CodeInterpreter;\n  private sandboxName: string | null = null;\n  private normalizeId: boolean = false;\n  private baseUrl: string | null = null;\n  private defaultSession: string | null = null;\n  envVars: Record<string, string> = {};\n  private logger: ReturnType<typeof createLogger>;\n  private keepAliveEnabled: boolean = false;\n  private activeMounts: Map<string, MountInfo> = new Map();\n  private transport: 'http' | 'websocket' = 'http';\n\n  /**\n   * Default container startup timeouts (conservative for production)\n   * Based on Cloudflare docs: \"Containers take several minutes to provision\"\n   */\n  private readonly DEFAULT_CONTAINER_TIMEOUTS = {\n    // Time to get container instance and launch VM\n    // @cloudflare/containers default: 8s (too short for cold starts)\n    instanceGetTimeoutMS: 30_000, // 30 seconds\n\n    // Time for application to start and ports to be ready\n    // @cloudflare/containers default: 20s\n    portReadyTimeoutMS: 90_000, // 90 seconds (allows for heavy containers)\n\n    // Polling interval for checking container readiness\n    // @cloudflare/containers default: 300ms (too aggressive)\n    waitIntervalMS: 1000 // 1 second (reduces load)\n  };\n\n  /**\n   * Active container timeout configuration\n   * Can be set via options, env vars, or defaults\n   */\n  private containerTimeouts = { ...this.DEFAULT_CONTAINER_TIMEOUTS };\n\n  /**\n   * Create a SandboxClient with current transport settings\n   */\n  private createSandboxClient(): SandboxClient {\n    return new SandboxClient({\n      logger: this.logger,\n      port: 3000,\n      stub: this,\n      ...(this.transport === 'websocket' && {\n        transportMode: 'websocket' as const,\n        wsUrl: 'ws://localhost:3000/ws'\n      })\n    });\n  }\n\n  constructor(ctx: DurableObjectState<{}>, env: Env) {\n    super(ctx, env);\n\n    const envObj = env as Record<string, unknown>;\n    // Set sandbox environment variables from env object\n    const sandboxEnvKeys = ['SANDBOX_LOG_LEVEL', 'SANDBOX_LOG_FORMAT'] as const;\n    sandboxEnvKeys.forEach((key) => {\n      if (envObj?.[key]) {\n        this.envVars[key] = String(envObj[key]);\n      }\n    });\n\n    // Initialize timeouts with env var fallbacks\n    this.containerTimeouts = this.getDefaultTimeouts(envObj);\n\n    this.logger = createLogger({\n      component: 'sandbox-do',\n      sandboxId: this.ctx.id.toString()\n    });\n\n    // Read transport setting from env var\n    const transportEnv = envObj?.SANDBOX_TRANSPORT;\n    if (transportEnv === 'websocket') {\n      this.transport = 'websocket';\n    } else if (transportEnv != null && transportEnv !== 'http') {\n      this.logger.warn(\n        `Invalid SANDBOX_TRANSPORT value: \"${transportEnv}\". Must be \"http\" or \"websocket\". Defaulting to \"http\".`\n      );\n    }\n\n    // Create client with transport based on env var (may be updated from storage)\n    this.client = this.createSandboxClient();\n\n    // Initialize code interpreter - pass 'this' after client is ready\n    // The CodeInterpreter extracts client.interpreter from the sandbox\n    this.codeInterpreter = new CodeInterpreter(this);\n\n    this.ctx.blockConcurrencyWhile(async () => {\n      this.sandboxName =\n        (await this.ctx.storage.get<string>('sandboxName')) || null;\n      this.normalizeId =\n        (await this.ctx.storage.get<boolean>('normalizeId')) || false;\n      this.defaultSession =\n        (await this.ctx.storage.get<string>('defaultSession')) || null;\n      this.keepAliveEnabled =\n        (await this.ctx.storage.get<boolean>('keepAliveEnabled')) || false;\n\n      // Load saved timeout configuration (highest priority)\n      const storedTimeouts =\n        await this.ctx.storage.get<\n          NonNullable<SandboxOptions['containerTimeouts']>\n        >('containerTimeouts');\n      if (storedTimeouts) {\n        this.containerTimeouts = {\n          ...this.containerTimeouts,\n          ...storedTimeouts\n        };\n      }\n    });\n  }\n\n  async setSandboxName(name: string, normalizeId?: boolean): Promise<void> {\n    if (!this.sandboxName) {\n      this.sandboxName = name;\n      this.normalizeId = normalizeId || false;\n      await this.ctx.storage.put('sandboxName', name);\n      await this.ctx.storage.put('normalizeId', this.normalizeId);\n    }\n  }\n\n  // RPC method to set the base URL\n  async setBaseUrl(baseUrl: string): Promise<void> {\n    if (!this.baseUrl) {\n      this.baseUrl = baseUrl;\n      await this.ctx.storage.put('baseUrl', baseUrl);\n    } else {\n      if (this.baseUrl !== baseUrl) {\n        throw new Error(\n          'Base URL already set and different from one previously provided'\n        );\n      }\n    }\n  }\n\n  // RPC method to set the sleep timeout\n  async setSleepAfter(sleepAfter: string | number): Promise<void> {\n    this.sleepAfter = sleepAfter;\n    // Reschedule activity timeout to apply the new sleepAfter value immediately\n    this.renewActivityTimeout();\n  }\n\n  // RPC method to enable keepAlive mode\n  async setKeepAlive(keepAlive: boolean): Promise<void> {\n    this.keepAliveEnabled = keepAlive;\n    await this.ctx.storage.put('keepAliveEnabled', keepAlive);\n  }\n\n  async setEnvVars(envVars: Record<string, string | undefined>): Promise<void> {\n    const { toSet, toUnset } = partitionEnvVars(envVars);\n\n    for (const key of toUnset) {\n      delete this.envVars[key];\n    }\n    this.envVars = { ...this.envVars, ...toSet };\n\n    if (this.defaultSession) {\n      for (const key of toUnset) {\n        const unsetCommand = `unset ${key}`;\n\n        const result = await this.client.commands.execute(\n          unsetCommand,\n          this.defaultSession\n        );\n\n        if (result.exitCode !== 0) {\n          throw new Error(\n            `Failed to unset ${key}: ${result.stderr || 'Unknown error'}`\n          );\n        }\n      }\n\n      for (const [key, value] of Object.entries(toSet)) {\n        const exportCommand = `export ${key}=${shellEscape(value)}`;\n\n        const result = await this.client.commands.execute(\n          exportCommand,\n          this.defaultSession\n        );\n\n        if (result.exitCode !== 0) {\n          throw new Error(\n            `Failed to set ${key}: ${result.stderr || 'Unknown error'}`\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * RPC method to configure container startup timeouts\n   */\n  async setContainerTimeouts(\n    timeouts: NonNullable<SandboxOptions['containerTimeouts']>\n  ): Promise<void> {\n    const validated = { ...this.containerTimeouts };\n\n    // Validate each timeout if provided\n    if (timeouts.instanceGetTimeoutMS !== undefined) {\n      validated.instanceGetTimeoutMS = this.validateTimeout(\n        timeouts.instanceGetTimeoutMS,\n        'instanceGetTimeoutMS',\n        5_000,\n        300_000\n      );\n    }\n\n    if (timeouts.portReadyTimeoutMS !== undefined) {\n      validated.portReadyTimeoutMS = this.validateTimeout(\n        timeouts.portReadyTimeoutMS,\n        'portReadyTimeoutMS',\n        10_000,\n        600_000\n      );\n    }\n\n    if (timeouts.waitIntervalMS !== undefined) {\n      validated.waitIntervalMS = this.validateTimeout(\n        timeouts.waitIntervalMS,\n        'waitIntervalMS',\n        100,\n        5_000\n      );\n    }\n\n    this.containerTimeouts = validated;\n\n    // Persist to storage\n    await this.ctx.storage.put('containerTimeouts', this.containerTimeouts);\n\n    this.logger.debug('Container timeouts updated', this.containerTimeouts);\n  }\n\n  /**\n   * Validate a timeout value is within acceptable range\n   * Throws error if invalid - used for user-provided values\n   */\n  private validateTimeout(\n    value: number,\n    name: string,\n    min: number,\n    max: number\n  ): number {\n    if (\n      typeof value !== 'number' ||\n      Number.isNaN(value) ||\n      !Number.isFinite(value)\n    ) {\n      throw new Error(`${name} must be a valid finite number, got ${value}`);\n    }\n\n    if (value < min || value > max) {\n      throw new Error(\n        `${name} must be between ${min}-${max}ms, got ${value}ms`\n      );\n    }\n\n    return value;\n  }\n\n  /**\n   * Get default timeouts with env var fallbacks and validation\n   * Precedence: SDK defaults < Env vars < User config\n   */\n  private getDefaultTimeouts(\n    env: Record<string, unknown>\n  ): typeof this.DEFAULT_CONTAINER_TIMEOUTS {\n    const parseAndValidate = (\n      envVar: string | undefined,\n      name: keyof typeof this.DEFAULT_CONTAINER_TIMEOUTS,\n      min: number,\n      max: number\n    ): number => {\n      const defaultValue = this.DEFAULT_CONTAINER_TIMEOUTS[name];\n\n      if (envVar === undefined) {\n        return defaultValue;\n      }\n\n      const parsed = parseInt(envVar, 10);\n\n      if (Number.isNaN(parsed)) {\n        this.logger.warn(\n          `Invalid ${name}: \"${envVar}\" is not a number. Using default: ${defaultValue}ms`\n        );\n        return defaultValue;\n      }\n\n      if (parsed < min || parsed > max) {\n        this.logger.warn(\n          `Invalid ${name}: ${parsed}ms. Must be ${min}-${max}ms. Using default: ${defaultValue}ms`\n        );\n        return defaultValue;\n      }\n\n      return parsed;\n    };\n\n    return {\n      instanceGetTimeoutMS: parseAndValidate(\n        getEnvString(env, 'SANDBOX_INSTANCE_TIMEOUT_MS'),\n        'instanceGetTimeoutMS',\n        5_000, // Min 5s\n        300_000 // Max 5min\n      ),\n      portReadyTimeoutMS: parseAndValidate(\n        getEnvString(env, 'SANDBOX_PORT_TIMEOUT_MS'),\n        'portReadyTimeoutMS',\n        10_000, // Min 10s\n        600_000 // Max 10min\n      ),\n      waitIntervalMS: parseAndValidate(\n        getEnvString(env, 'SANDBOX_POLL_INTERVAL_MS'),\n        'waitIntervalMS',\n        100, // Min 100ms\n        5_000 // Max 5s\n      )\n    };\n  }\n\n  /*\n   * Mount an S3-compatible bucket as a local directory using S3FS-FUSE\n   *\n   * Requires explicit endpoint URL. Credentials are auto-detected from environment\n   * variables or can be provided explicitly.\n   *\n   * @param bucket - Bucket name\n   * @param mountPath - Absolute path in container to mount at\n   * @param options - Configuration options with required endpoint\n   * @throws MissingCredentialsError if no credentials found in environment\n   * @throws S3FSMountError if S3FS mount command fails\n   * @throws InvalidMountConfigError if bucket name, mount path, or endpoint is invalid\n   */\n  async mountBucket(\n    bucket: string,\n    mountPath: string,\n    options: MountBucketOptions\n  ): Promise<void> {\n    this.logger.info(`Mounting bucket ${bucket} to ${mountPath}`);\n\n    const prefix = options.prefix || undefined;\n\n    this.validateMountOptions(bucket, mountPath, { ...options, prefix });\n\n    // Build s3fs source: bucket name with optional prefix (e.g., \"mybucket:/prefix/\")\n    const s3fsSource = buildS3fsSource(bucket, prefix);\n\n    // Detect provider from explicit option or URL pattern\n    const provider: BucketProvider | null =\n      options.provider || detectProviderFromUrl(options.endpoint);\n\n    this.logger.debug(`Detected provider: ${provider || 'unknown'}`, {\n      explicitProvider: options.provider,\n      prefix\n    });\n\n    // Detect credentials\n    const credentials = detectCredentials(options, this.envVars);\n\n    // Generate unique password file path\n    const passwordFilePath = this.generatePasswordFilePath();\n\n    // Reserve mount path before async operations so concurrent mounts see it\n    this.activeMounts.set(mountPath, {\n      bucket: s3fsSource,\n      mountPath,\n      endpoint: options.endpoint,\n      provider,\n      passwordFilePath,\n      mounted: false\n    });\n\n    try {\n      // Create password file with credentials (uses bucket name only, not prefix)\n      await this.createPasswordFile(passwordFilePath, bucket, credentials);\n\n      // Create mount directory\n      await this.exec(`mkdir -p ${shellEscape(mountPath)}`);\n\n      // Execute S3FS mount with password file (uses full s3fs source with prefix)\n      await this.executeS3FSMount(\n        s3fsSource,\n        mountPath,\n        options,\n        provider,\n        passwordFilePath\n      );\n\n      // Mark as successfully mounted\n      this.activeMounts.set(mountPath, {\n        bucket: s3fsSource,\n        mountPath,\n        endpoint: options.endpoint,\n        provider,\n        passwordFilePath,\n        mounted: true\n      });\n\n      this.logger.info(`Successfully mounted bucket ${bucket} to ${mountPath}`);\n    } catch (error) {\n      // Clean up password file on failure\n      await this.deletePasswordFile(passwordFilePath);\n\n      // Clean up reservation on failure\n      this.activeMounts.delete(mountPath);\n      throw error;\n    }\n  }\n\n  /**\n   * Manually unmount a bucket filesystem\n   *\n   * @param mountPath - Absolute path where the bucket is mounted\n   * @throws InvalidMountConfigError if mount path doesn't exist or isn't mounted\n   */\n  async unmountBucket(mountPath: string): Promise<void> {\n    this.logger.info(`Unmounting bucket from ${mountPath}`);\n\n    // Look up mount by path\n    const mountInfo = this.activeMounts.get(mountPath);\n\n    // Throw error if mount doesn't exist\n    if (!mountInfo) {\n      throw new InvalidMountConfigError(\n        `No active mount found at path: ${mountPath}`\n      );\n    }\n\n    // Unmount the filesystem\n    try {\n      await this.exec(`fusermount -u ${shellEscape(mountPath)}`);\n      mountInfo.mounted = false;\n\n      // Only remove from tracking if unmount succeeded\n      this.activeMounts.delete(mountPath);\n    } finally {\n      // Always cleanup password file, even if unmount fails\n      await this.deletePasswordFile(mountInfo.passwordFilePath);\n    }\n\n    this.logger.info(`Successfully unmounted bucket from ${mountPath}`);\n  }\n\n  /**\n   * Validate mount options\n   */\n  private validateMountOptions(\n    bucket: string,\n    mountPath: string,\n    options: MountBucketOptions\n  ): void {\n    // Require endpoint field\n    if (!options.endpoint) {\n      throw new InvalidMountConfigError(\n        'Endpoint is required. Provide the full S3-compatible endpoint URL.'\n      );\n    }\n\n    // Basic URL validation\n    try {\n      new URL(options.endpoint);\n    } catch (error) {\n      throw new InvalidMountConfigError(\n        `Invalid endpoint URL: \"${options.endpoint}\". Must be a valid HTTP(S) URL.`\n      );\n    }\n\n    validateBucketName(bucket, mountPath);\n\n    // Validate mount path is absolute\n    if (!mountPath.startsWith('/')) {\n      throw new InvalidMountConfigError(\n        `Mount path must be absolute (start with /): \"${mountPath}\"`\n      );\n    }\n\n    // Check for duplicate mount path\n    if (this.activeMounts.has(mountPath)) {\n      const existingMount = this.activeMounts.get(mountPath);\n      throw new InvalidMountConfigError(\n        `Mount path \"${mountPath}\" is already in use by bucket \"${existingMount?.bucket}\". ` +\n          `Unmount the existing bucket first or use a different mount path.`\n      );\n    }\n\n    // Validate prefix format if provided\n    if (options.prefix !== undefined) {\n      validatePrefix(options.prefix);\n    }\n  }\n\n  /**\n   * Generate unique password file path for s3fs credentials\n   */\n  private generatePasswordFilePath(): string {\n    const uuid = crypto.randomUUID();\n    return `/tmp/.passwd-s3fs-${uuid}`;\n  }\n\n  /**\n   * Create password file with s3fs credentials\n   * Format: bucket:accessKeyId:secretAccessKey\n   */\n  private async createPasswordFile(\n    passwordFilePath: string,\n    bucket: string,\n    credentials: BucketCredentials\n  ): Promise<void> {\n    const content = `${bucket}:${credentials.accessKeyId}:${credentials.secretAccessKey}`;\n\n    await this.writeFile(passwordFilePath, content);\n\n    await this.exec(`chmod 0600 ${shellEscape(passwordFilePath)}`);\n\n    this.logger.debug(`Created password file: ${passwordFilePath}`);\n  }\n\n  /**\n   * Delete password file\n   */\n  private async deletePasswordFile(passwordFilePath: string): Promise<void> {\n    try {\n      await this.exec(`rm -f ${shellEscape(passwordFilePath)}`);\n      this.logger.debug(`Deleted password file: ${passwordFilePath}`);\n    } catch (error) {\n      this.logger.warn(`Failed to delete password file ${passwordFilePath}`, {\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  }\n\n  /**\n   * Execute S3FS mount command\n   */\n  private async executeS3FSMount(\n    bucket: string,\n    mountPath: string,\n    options: MountBucketOptions,\n    provider: BucketProvider | null,\n    passwordFilePath: string\n  ): Promise<void> {\n    // Resolve s3fs options (provider defaults + user overrides)\n    const resolvedOptions = resolveS3fsOptions(provider, options.s3fsOptions);\n\n    // Build s3fs mount command\n    const s3fsArgs: string[] = [];\n\n    // Add password file option FIRST\n    s3fsArgs.push(`passwd_file=${passwordFilePath}`);\n\n    // Add resolved provider-specific and user options\n    s3fsArgs.push(...resolvedOptions);\n\n    // Add read-only flag if requested\n    if (options.readOnly) {\n      s3fsArgs.push('ro');\n    }\n\n    // Add endpoint URL\n    s3fsArgs.push(`url=${options.endpoint}`);\n\n    // Build final command with escaped options\n    const optionsStr = shellEscape(s3fsArgs.join(','));\n    const mountCmd = `s3fs ${shellEscape(bucket)} ${shellEscape(mountPath)} -o ${optionsStr}`;\n\n    this.logger.debug('Executing s3fs mount', {\n      bucket,\n      mountPath,\n      provider,\n      resolvedOptions\n    });\n\n    // Execute mount command\n    const result = await this.exec(mountCmd);\n\n    if (result.exitCode !== 0) {\n      throw new S3FSMountError(\n        `S3FS mount failed: ${result.stderr || result.stdout || 'Unknown error'}`\n      );\n    }\n\n    this.logger.debug('Mount command executed successfully');\n  }\n\n  /**\n   * Cleanup and destroy the sandbox container\n   */\n  override async destroy(): Promise<void> {\n    this.logger.info('Destroying sandbox container');\n\n    // Disconnect WebSocket transport if active\n    this.client.disconnect();\n\n    // Unmount all mounted buckets and cleanup password files\n    for (const [mountPath, mountInfo] of this.activeMounts.entries()) {\n      if (mountInfo.mounted) {\n        try {\n          this.logger.info(\n            `Unmounting bucket ${mountInfo.bucket} from ${mountPath}`\n          );\n          await this.exec(`fusermount -u ${shellEscape(mountPath)}`);\n          mountInfo.mounted = false;\n        } catch (error) {\n          const errorMsg =\n            error instanceof Error ? error.message : String(error);\n          this.logger.warn(\n            `Failed to unmount bucket ${mountInfo.bucket} from ${mountPath}: ${errorMsg}`\n          );\n        }\n      }\n\n      // Always cleanup password file\n      await this.deletePasswordFile(mountInfo.passwordFilePath);\n    }\n\n    await super.destroy();\n  }\n\n  override onStart() {\n    this.logger.debug('Sandbox started');\n\n    // Check version compatibility asynchronously (don't block startup)\n    this.checkVersionCompatibility().catch((error) => {\n      this.logger.error(\n        'Version compatibility check failed',\n        error instanceof Error ? error : new Error(String(error))\n      );\n    });\n  }\n\n  /**\n   * Check if the container version matches the SDK version\n   * Logs a warning if there's a mismatch\n   */\n  private async checkVersionCompatibility(): Promise<void> {\n    try {\n      // Get the SDK version (imported from version.ts)\n      const sdkVersion = SDK_VERSION;\n\n      // Get container version\n      const containerVersion = await this.client.utils.getVersion();\n\n      // If container version is unknown, it's likely an old container without the endpoint\n      if (containerVersion === 'unknown') {\n        this.logger.warn(\n          'Container version check: Container version could not be determined. ' +\n            'This may indicate an outdated container image. ' +\n            'Please update your container to match SDK version ' +\n            sdkVersion\n        );\n        return;\n      }\n\n      // Check if versions match\n      if (containerVersion !== sdkVersion) {\n        const message =\n          `Version mismatch detected! SDK version (${sdkVersion}) does not match ` +\n          `container version (${containerVersion}). This may cause compatibility issues. ` +\n          `Please update your container image to version ${sdkVersion}`;\n\n        // Log warning - we can't reliably detect dev vs prod environment in Durable Objects\n        // so we always use warning level as requested by the user\n        this.logger.warn(message);\n      } else {\n        this.logger.debug('Version check passed', {\n          sdkVersion,\n          containerVersion\n        });\n      }\n    } catch (error) {\n      // Don't fail the sandbox initialization if version check fails\n      this.logger.debug('Version compatibility check encountered an error', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n  }\n\n  override async onStop() {\n    this.logger.debug('Sandbox stopped');\n\n    // Clear in-memory state that references the old container\n    // This prevents stale references after container restarts\n    this.defaultSession = null;\n    this.activeMounts.clear();\n\n    // Persist cleanup to storage so state is clean on next container start\n    await Promise.all([\n      this.ctx.storage.delete('portTokens'),\n      this.ctx.storage.delete('defaultSession')\n    ]);\n  }\n\n  override onError(error: unknown) {\n    this.logger.error(\n      'Sandbox error',\n      error instanceof Error ? error : new Error(String(error))\n    );\n  }\n\n  /**\n   * Override Container.containerFetch to use production-friendly timeouts\n   * Automatically starts container with longer timeouts if not running\n   */\n  override async containerFetch(\n    requestOrUrl: Request | string | URL,\n    portOrInit?: number | RequestInit,\n    portParam?: number\n  ): Promise<Response> {\n    // Parse arguments to extract request and port\n    const { request, port } = this.parseContainerFetchArgs(\n      requestOrUrl,\n      portOrInit,\n      portParam\n    );\n\n    const state = await this.getState();\n\n    // If container not healthy, start it with production timeouts\n    if (state.status !== 'healthy') {\n      try {\n        this.logger.debug('Starting container with configured timeouts', {\n          instanceTimeout: this.containerTimeouts.instanceGetTimeoutMS,\n          portTimeout: this.containerTimeouts.portReadyTimeoutMS\n        });\n\n        await this.startAndWaitForPorts({\n          ports: port,\n          cancellationOptions: {\n            instanceGetTimeoutMS: this.containerTimeouts.instanceGetTimeoutMS,\n            portReadyTimeoutMS: this.containerTimeouts.portReadyTimeoutMS,\n            waitInterval: this.containerTimeouts.waitIntervalMS,\n            abort: request.signal\n          }\n        });\n      } catch (e) {\n        // 1. Provisioning: Container VM not yet available\n        if (this.isNoInstanceError(e)) {\n          return new Response(\n            'Container is currently provisioning. This can take several minutes on first deployment. Please retry in a moment.',\n            {\n              status: 503,\n              headers: { 'Retry-After': '10' }\n            }\n          );\n        }\n\n        // 2. Transient startup errors: Container starting, port not ready yet\n        if (this.isTransientStartupError(e)) {\n          this.logger.debug(\n            'Transient container startup error, returning 503',\n            {\n              error: e instanceof Error ? e.message : String(e)\n            }\n          );\n          return new Response(\n            'Container is starting. Please retry in a moment.',\n            {\n              status: 503,\n              headers: { 'Retry-After': '3' }\n            }\n          );\n        }\n\n        // 3. Permanent errors: Configuration issues, missing images, etc.\n        this.logger.error(\n          'Container startup failed with permanent error',\n          e instanceof Error ? e : new Error(String(e))\n        );\n        return new Response(\n          `Failed to start container: ${e instanceof Error ? e.message : String(e)}`,\n          { status: 500 }\n        );\n      }\n    }\n\n    // Delegate to parent for the actual fetch (handles TCP port access internally)\n    return await super.containerFetch(requestOrUrl, portOrInit, portParam);\n  }\n\n  /**\n   * Helper: Check if error is \"no container instance available\"\n   * This indicates the container VM is still being provisioned.\n   */\n  private isNoInstanceError(error: unknown): boolean {\n    return (\n      error instanceof Error &&\n      error.message.toLowerCase().includes('no container instance')\n    );\n  }\n\n  /**\n   * Helper: Check if error is a transient startup error that should trigger retry\n   *\n   * These errors occur during normal container startup and are recoverable:\n   * - Port not yet mapped (container starting, app not listening yet)\n   * - Connection refused (port mapped but app not ready)\n   * - Timeouts during startup (recoverable with retry)\n   * - Network transients (temporary connectivity issues)\n   *\n   * Errors NOT included (permanent failures):\n   * - \"no such image\" - missing Docker image\n   * - \"container already exists\" - name collision\n   * - Configuration errors\n   */\n  private isTransientStartupError(error: unknown): boolean {\n    if (!(error instanceof Error)) return false;\n\n    const msg = error.message.toLowerCase();\n\n    // Transient errors from workerd container-client.c++ and @cloudflare/containers\n    const transientPatterns = [\n      // Port mapping race conditions (workerd DockerPort::connect)\n      'container port not found',\n      'connection refused: container port',\n\n      // Application startup delays (@cloudflare/containers)\n      'the container is not listening',\n      'failed to verify port',\n      'container did not start',\n\n      // Network transients (workerd)\n      'network connection lost',\n      'container suddenly disconnected',\n\n      // Monitor race conditions (workerd)\n      'monitor failed to find container',\n\n      // Timeouts (various layers)\n      'timed out',\n      'timeout',\n      'the operation was aborted'\n    ];\n\n    return transientPatterns.some((pattern) => msg.includes(pattern));\n  }\n\n  /**\n   * Helper: Parse containerFetch arguments (supports multiple signatures)\n   */\n  private parseContainerFetchArgs(\n    requestOrUrl: Request | string | URL,\n    portOrInit?: number | RequestInit,\n    portParam?: number\n  ): { request: Request; port: number } {\n    let request: Request;\n    let port: number | undefined;\n\n    if (requestOrUrl instanceof Request) {\n      request = requestOrUrl;\n      port = typeof portOrInit === 'number' ? portOrInit : undefined;\n    } else {\n      const url =\n        typeof requestOrUrl === 'string'\n          ? requestOrUrl\n          : requestOrUrl.toString();\n      const init = typeof portOrInit === 'number' ? {} : portOrInit || {};\n      port =\n        typeof portOrInit === 'number'\n          ? portOrInit\n          : typeof portParam === 'number'\n            ? portParam\n            : undefined;\n      request = new Request(url, init);\n    }\n\n    port ??= this.defaultPort;\n\n    if (port === undefined) {\n      throw new Error('No port specified for container fetch');\n    }\n\n    return { request, port };\n  }\n\n  /**\n   * Override onActivityExpired to prevent automatic shutdown when keepAlive is enabled\n   * When keepAlive is disabled, calls parent implementation which stops the container\n   */\n  override async onActivityExpired(): Promise<void> {\n    if (this.keepAliveEnabled) {\n      this.logger.debug(\n        'Activity expired but keepAlive is enabled - container will stay alive'\n      );\n      // Do nothing - don't call stop(), container stays alive\n    } else {\n      // Default behavior: stop the container\n      this.logger.debug('Activity expired - stopping container');\n      await super.onActivityExpired();\n    }\n  }\n\n  // Override fetch to route internal container requests to appropriate ports\n  override async fetch(request: Request): Promise<Response> {\n    // Extract or generate trace ID from request\n    const traceId =\n      TraceContext.fromHeaders(request.headers) || TraceContext.generate();\n\n    // Create request-specific logger with trace ID\n    const requestLogger = this.logger.child({ traceId, operation: 'fetch' });\n\n    const url = new URL(request.url);\n\n    // Capture and store the sandbox name from the header if present\n    if (!this.sandboxName && request.headers.has('X-Sandbox-Name')) {\n      const name = request.headers.get('X-Sandbox-Name')!;\n      this.sandboxName = name;\n      await this.ctx.storage.put('sandboxName', name);\n    }\n\n    // Detect WebSocket upgrade request (RFC 6455 compliant)\n    const upgradeHeader = request.headers.get('Upgrade');\n    const connectionHeader = request.headers.get('Connection');\n    const isWebSocket =\n      upgradeHeader?.toLowerCase() === 'websocket' &&\n      connectionHeader?.toLowerCase().includes('upgrade');\n\n    if (isWebSocket) {\n      // WebSocket path: Let parent Container class handle WebSocket proxying\n      // This bypasses containerFetch() which uses JSRPC and cannot handle WebSocket upgrades\n      try {\n        requestLogger.debug('WebSocket upgrade requested', {\n          path: url.pathname,\n          port: this.determinePort(url)\n        });\n        return await super.fetch(request);\n      } catch (error) {\n        requestLogger.error(\n          'WebSocket connection failed',\n          error instanceof Error ? error : new Error(String(error)),\n          { path: url.pathname }\n        );\n        throw error;\n      }\n    }\n\n    // Non-WebSocket: Use existing port determination and HTTP routing logic\n    const port = this.determinePort(url);\n\n    // Route to the appropriate port\n    return await this.containerFetch(request, port);\n  }\n\n  wsConnect(request: Request, port: number): Promise<Response> {\n    // Stub - actual implementation is attached by getSandbox() on the stub object\n    throw new Error(\n      'wsConnect must be called on the stub returned by getSandbox()'\n    );\n  }\n\n  private determinePort(url: URL): number {\n    // Extract port from proxy requests (e.g., /proxy/8080/*)\n    const proxyMatch = url.pathname.match(/^\\/proxy\\/(\\d+)/);\n    if (proxyMatch) {\n      return parseInt(proxyMatch[1], 10);\n    }\n\n    // All other requests go to control plane on port 3000\n    // This includes /api/* endpoints and any other control requests\n    return 3000;\n  }\n\n  /**\n   * Ensure default session exists - lazy initialization\n   * This is called automatically by all public methods that need a session\n   *\n   * The session ID is persisted to DO storage. On container restart, if the\n   * container already has this session (from a previous instance), we sync\n   * our state rather than failing on duplicate creation.\n   */\n  private async ensureDefaultSession(): Promise<string> {\n    const sessionId = `sandbox-${this.sandboxName || 'default'}`;\n\n    // Fast path: session already initialized in this instance\n    if (this.defaultSession === sessionId) {\n      return this.defaultSession;\n    }\n\n    // Create session in container\n    try {\n      await this.client.utils.createSession({\n        id: sessionId,\n        env: this.envVars || {},\n        cwd: '/workspace'\n      });\n\n      this.defaultSession = sessionId;\n      await this.ctx.storage.put('defaultSession', sessionId);\n      this.logger.debug('Default session initialized', { sessionId });\n    } catch (error: unknown) {\n      // Session may already exist (e.g., after hot reload or concurrent request)\n      if (error instanceof SessionAlreadyExistsError) {\n        this.logger.debug(\n          'Session exists in container but not in DO state, syncing',\n          { sessionId }\n        );\n        this.defaultSession = sessionId;\n        await this.ctx.storage.put('defaultSession', sessionId);\n      } else {\n        throw error;\n      }\n    }\n\n    return this.defaultSession;\n  }\n\n  // Enhanced exec method - always returns ExecResult with optional streaming\n  // This replaces the old exec method to match ISandbox interface\n  async exec(command: string, options?: ExecOptions): Promise<ExecResult> {\n    const session = await this.ensureDefaultSession();\n    return this.execWithSession(command, session, options);\n  }\n\n  /**\n   * Internal session-aware exec implementation\n   * Used by both public exec() and session wrappers\n   */\n  private async execWithSession(\n    command: string,\n    sessionId: string,\n    options?: ExecOptions\n  ): Promise<ExecResult> {\n    const startTime = Date.now();\n    const timestamp = new Date().toISOString();\n\n    let timeoutId: NodeJS.Timeout | undefined;\n\n    try {\n      // Handle cancellation\n      if (options?.signal?.aborted) {\n        throw new Error('Operation was aborted');\n      }\n\n      let result: ExecResult;\n\n      if (options?.stream && options?.onOutput) {\n        // Streaming with callbacks - we need to collect the final result\n        result = await this.executeWithStreaming(\n          command,\n          sessionId,\n          options,\n          startTime,\n          timestamp\n        );\n      } else {\n        // Regular execution with session\n        const commandOptions =\n          options &&\n          (options.timeout !== undefined ||\n            options.env !== undefined ||\n            options.cwd !== undefined)\n            ? {\n                timeoutMs: options.timeout,\n                env: options.env,\n                cwd: options.cwd\n              }\n            : undefined;\n\n        const response = await this.client.commands.execute(\n          command,\n          sessionId,\n          commandOptions\n        );\n\n        const duration = Date.now() - startTime;\n        result = this.mapExecuteResponseToExecResult(\n          response,\n          duration,\n          sessionId\n        );\n      }\n\n      // Call completion callback if provided\n      if (options?.onComplete) {\n        options.onComplete(result);\n      }\n\n      return result;\n    } catch (error) {\n      if (options?.onError && error instanceof Error) {\n        options.onError(error);\n      }\n      throw error;\n    } finally {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    }\n  }\n\n  private async executeWithStreaming(\n    command: string,\n    sessionId: string,\n    options: ExecOptions,\n    startTime: number,\n    timestamp: string\n  ): Promise<ExecResult> {\n    let stdout = '';\n    let stderr = '';\n\n    try {\n      const stream = await this.client.commands.executeStream(\n        command,\n        sessionId,\n        {\n          timeoutMs: options.timeout,\n          env: options.env,\n          cwd: options.cwd\n        }\n      );\n\n      for await (const event of parseSSEStream<ExecEvent>(stream)) {\n        // Check for cancellation\n        if (options.signal?.aborted) {\n          throw new Error('Operation was aborted');\n        }\n\n        switch (event.type) {\n          case 'stdout':\n          case 'stderr':\n            if (event.data) {\n              // Update accumulated output\n              if (event.type === 'stdout') stdout += event.data;\n              if (event.type === 'stderr') stderr += event.data;\n\n              // Call user's callback\n              if (options.onOutput) {\n                options.onOutput(event.type, event.data);\n              }\n            }\n            break;\n\n          case 'complete': {\n            // Use result from complete event if available\n            const duration = Date.now() - startTime;\n            return {\n              success: (event.exitCode ?? 0) === 0,\n              exitCode: event.exitCode ?? 0,\n              stdout,\n              stderr,\n              command,\n              duration,\n              timestamp,\n              sessionId\n            };\n          }\n\n          case 'error':\n            throw new Error(event.data || 'Command execution failed');\n        }\n      }\n\n      // If we get here without a complete event, something went wrong\n      throw new Error('Stream ended without completion event');\n    } catch (error) {\n      if (options.signal?.aborted) {\n        throw new Error('Operation was aborted');\n      }\n      throw error;\n    }\n  }\n\n  private mapExecuteResponseToExecResult(\n    response: ExecuteResponse,\n    duration: number,\n    sessionId?: string\n  ): ExecResult {\n    return {\n      success: response.success,\n      exitCode: response.exitCode,\n      stdout: response.stdout,\n      stderr: response.stderr,\n      command: response.command,\n      duration,\n      timestamp: response.timestamp,\n      sessionId\n    };\n  }\n\n  /**\n   * Create a Process domain object from HTTP client DTO\n   * Centralizes process object creation with bound methods\n   * This eliminates duplication across startProcess, listProcesses, getProcess, and session wrappers\n   */\n  private createProcessFromDTO(\n    data: {\n      id: string;\n      pid?: number;\n      command: string;\n      status: ProcessStatus;\n      startTime: string | Date;\n      endTime?: string | Date;\n      exitCode?: number;\n    },\n    sessionId: string\n  ): Process {\n    return {\n      id: data.id,\n      pid: data.pid,\n      command: data.command,\n      status: data.status,\n      startTime:\n        typeof data.startTime === 'string'\n          ? new Date(data.startTime)\n          : data.startTime,\n      endTime: data.endTime\n        ? typeof data.endTime === 'string'\n          ? new Date(data.endTime)\n          : data.endTime\n        : undefined,\n      exitCode: data.exitCode,\n      sessionId,\n\n      kill: async (signal?: string) => {\n        await this.killProcess(data.id, signal);\n      },\n\n      getStatus: async () => {\n        const current = await this.getProcess(data.id);\n        return current?.status || 'error';\n      },\n\n      getLogs: async () => {\n        const logs = await this.getProcessLogs(data.id);\n        return { stdout: logs.stdout, stderr: logs.stderr };\n      },\n\n      waitForLog: async (\n        pattern: string | RegExp,\n        timeout?: number\n      ): Promise<WaitForLogResult> => {\n        return this.waitForLogPattern(data.id, data.command, pattern, timeout);\n      },\n\n      waitForPort: async (\n        port: number,\n        options?: WaitForPortOptions\n      ): Promise<void> => {\n        await this.waitForPortReady(data.id, data.command, port, options);\n      },\n\n      waitForExit: async (timeout?: number): Promise<WaitForExitResult> => {\n        return this.waitForProcessExit(data.id, data.command, timeout);\n      }\n    };\n  }\n\n  /**\n   * Wait for a log pattern to appear in process output\n   */\n  private async waitForLogPattern(\n    processId: string,\n    command: string,\n    pattern: string | RegExp,\n    timeout?: number\n  ): Promise<WaitForLogResult> {\n    const startTime = Date.now();\n    const conditionStr = this.conditionToString(pattern);\n    let collectedStdout = '';\n    let collectedStderr = '';\n\n    // First check existing logs\n    try {\n      const existingLogs = await this.getProcessLogs(processId);\n      // Ensure existing logs end with newline for proper line separation from streamed output\n      collectedStdout = existingLogs.stdout;\n      if (collectedStdout && !collectedStdout.endsWith('\\n')) {\n        collectedStdout += '\\n';\n      }\n      collectedStderr = existingLogs.stderr;\n      if (collectedStderr && !collectedStderr.endsWith('\\n')) {\n        collectedStderr += '\\n';\n      }\n\n      // Check stdout\n      const stdoutResult = this.matchPattern(existingLogs.stdout, pattern);\n      if (stdoutResult) {\n        return stdoutResult;\n      }\n\n      // Check stderr\n      const stderrResult = this.matchPattern(existingLogs.stderr, pattern);\n      if (stderrResult) {\n        return stderrResult;\n      }\n    } catch (error) {\n      // Process might have already exited, continue to streaming\n      this.logger.debug('Could not get existing logs, will stream', {\n        processId,\n        error: error instanceof Error ? error.message : String(error)\n      });\n    }\n\n    // Stream new logs and check for pattern\n    const stream = await this.streamProcessLogs(processId);\n\n    // Set up timeout if specified\n    let timeoutId: ReturnType<typeof setTimeout> | undefined;\n    let timeoutPromise: Promise<never> | undefined;\n\n    if (timeout !== undefined) {\n      const remainingTime = timeout - (Date.now() - startTime);\n      if (remainingTime <= 0) {\n        throw this.createReadyTimeoutError(\n          processId,\n          command,\n          conditionStr,\n          timeout\n        );\n      }\n\n      timeoutPromise = new Promise<never>((_, reject) => {\n        timeoutId = setTimeout(() => {\n          reject(\n            this.createReadyTimeoutError(\n              processId,\n              command,\n              conditionStr,\n              timeout\n            )\n          );\n        }, remainingTime);\n      });\n    }\n\n    try {\n      // Process stream\n      const streamProcessor = async (): Promise<WaitForLogResult> => {\n        const DEBOUNCE_MS = 50;\n        let lastCheckTime = 0;\n        let pendingCheck = false;\n\n        const checkPattern = (): WaitForLogResult | null => {\n          // Check both stdout and stderr buffers\n          const stdoutResult = this.matchPattern(collectedStdout, pattern);\n          if (stdoutResult) return stdoutResult;\n          const stderrResult = this.matchPattern(collectedStderr, pattern);\n          if (stderrResult) return stderrResult;\n          return null;\n        };\n\n        for await (const event of parseSSEStream<LogEvent>(stream)) {\n          // Handle different event types\n          if (event.type === 'stdout' || event.type === 'stderr') {\n            const data = event.data || '';\n\n            if (event.type === 'stdout') {\n              collectedStdout += data;\n            } else {\n              collectedStderr += data;\n            }\n            pendingCheck = true;\n\n            // Debounce pattern matching - check at most every 50ms\n            const now = Date.now();\n            if (now - lastCheckTime >= DEBOUNCE_MS) {\n              lastCheckTime = now;\n              pendingCheck = false;\n              const result = checkPattern();\n              if (result) return result;\n            }\n          }\n\n          // Process exited - do final check before throwing\n          if (event.type === 'exit') {\n            if (pendingCheck) {\n              const result = checkPattern();\n              if (result) return result;\n            }\n            throw this.createExitedBeforeReadyError(\n              processId,\n              command,\n              conditionStr,\n              event.exitCode ?? 1\n            );\n          }\n        }\n\n        // Stream ended - do final check before throwing\n        if (pendingCheck) {\n          const result = checkPattern();\n          if (result) return result;\n        }\n        // Stream ended without finding pattern - this indicates process exited\n        throw this.createExitedBeforeReadyError(\n          processId,\n          command,\n          conditionStr,\n          0\n        );\n      };\n\n      // Race with timeout if specified, otherwise just run stream processor\n      if (timeoutPromise) {\n        return await Promise.race([streamProcessor(), timeoutPromise]);\n      }\n      return await streamProcessor();\n    } finally {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    }\n  }\n\n  /**\n   * Wait for a port to become available (for process readiness checking)\n   */\n  private async waitForPortReady(\n    processId: string,\n    command: string,\n    port: number,\n    options?: WaitForPortOptions\n  ): Promise<void> {\n    const {\n      mode = 'http',\n      path = '/',\n      status = { min: 200, max: 399 },\n      timeout,\n      interval = 500\n    } = options ?? {};\n\n    const conditionStr =\n      mode === 'http' ? `port ${port} (HTTP ${path})` : `port ${port} (TCP)`;\n\n    // Normalize status to min/max\n    const statusMin = typeof status === 'number' ? status : status.min;\n    const statusMax = typeof status === 'number' ? status : status.max;\n\n    // Open streaming watch - container handles internal polling\n    const stream = await this.client.ports.watchPort({\n      port,\n      mode,\n      path,\n      statusMin,\n      statusMax,\n      processId,\n      interval\n    });\n\n    // Set up timeout if specified\n    let timeoutId: ReturnType<typeof setTimeout> | undefined;\n    let timeoutPromise: Promise<never> | undefined;\n\n    if (timeout !== undefined) {\n      timeoutPromise = new Promise<never>((_, reject) => {\n        timeoutId = setTimeout(() => {\n          reject(\n            this.createReadyTimeoutError(\n              processId,\n              command,\n              conditionStr,\n              timeout\n            )\n          );\n        }, timeout);\n      });\n    }\n\n    try {\n      const streamProcessor = async (): Promise<void> => {\n        for await (const event of parseSSEStream<PortWatchEvent>(stream)) {\n          switch (event.type) {\n            case 'ready':\n              return; // Success!\n            case 'process_exited':\n              throw this.createExitedBeforeReadyError(\n                processId,\n                command,\n                conditionStr,\n                event.exitCode ?? 1\n              );\n            case 'error':\n              throw new Error(event.error || 'Port watch failed');\n            // 'watching' - continue\n          }\n        }\n        throw new Error('Port watch stream ended unexpectedly');\n      };\n\n      if (timeoutPromise) {\n        await Promise.race([streamProcessor(), timeoutPromise]);\n      } else {\n        await streamProcessor();\n      }\n    } finally {\n      if (timeoutId) clearTimeout(timeoutId);\n      // Cancel the stream to stop container-side polling\n      try {\n        await stream.cancel();\n      } catch {\n        // Stream may already be closed\n      }\n    }\n  }\n\n  /**\n   * Wait for a process to exit\n   * Returns the exit code\n   */\n  private async waitForProcessExit(\n    processId: string,\n    command: string,\n    timeout?: number\n  ): Promise<WaitForExitResult> {\n    const stream = await this.streamProcessLogs(processId);\n\n    // Set up timeout if specified\n    let timeoutId: ReturnType<typeof setTimeout> | undefined;\n    let timeoutPromise: Promise<never> | undefined;\n\n    if (timeout !== undefined) {\n      timeoutPromise = new Promise<never>((_, reject) => {\n        timeoutId = setTimeout(() => {\n          reject(\n            this.createReadyTimeoutError(\n              processId,\n              command,\n              'process exit',\n              timeout\n            )\n          );\n        }, timeout);\n      });\n    }\n\n    try {\n      const streamProcessor = async (): Promise<WaitForExitResult> => {\n        for await (const event of parseSSEStream<LogEvent>(stream)) {\n          if (event.type === 'exit') {\n            return {\n              exitCode: event.exitCode ?? 1\n            };\n          }\n        }\n\n        // Stream ended without exit event - shouldn't happen, but handle gracefully\n        throw new Error(\n          `Process ${processId} stream ended unexpectedly without exit event`\n        );\n      };\n\n      if (timeoutPromise) {\n        return await Promise.race([streamProcessor(), timeoutPromise]);\n      }\n      return await streamProcessor();\n    } finally {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    }\n  }\n\n  /**\n   * Match a pattern against text\n   */\n  private matchPattern(\n    text: string,\n    pattern: string | RegExp\n  ): WaitForLogResult | null {\n    if (typeof pattern === 'string') {\n      // Simple substring match\n      if (text.includes(pattern)) {\n        // Find the line containing the pattern\n        const lines = text.split('\\n');\n        for (const line of lines) {\n          if (line.includes(pattern)) {\n            return { line };\n          }\n        }\n        return { line: pattern };\n      }\n    } else {\n      const safePattern = new RegExp(\n        pattern.source,\n        pattern.flags.replace('g', '')\n      );\n      const match = text.match(safePattern);\n      if (match) {\n        // Find the full line containing the match\n        const lines = text.split('\\n');\n        for (const line of lines) {\n          const lineMatch = line.match(safePattern);\n          if (lineMatch) {\n            return { line, match: lineMatch };\n          }\n        }\n        return { line: match[0], match };\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Convert a log pattern to a human-readable string\n   */\n  private conditionToString(pattern: string | RegExp): string {\n    if (typeof pattern === 'string') {\n      return `\"${pattern}\"`;\n    }\n    return pattern.toString();\n  }\n\n  /**\n   * Create a ProcessReadyTimeoutError\n   */\n  private createReadyTimeoutError(\n    processId: string,\n    command: string,\n    condition: string,\n    timeout: number\n  ): ProcessReadyTimeoutError {\n    return new ProcessReadyTimeoutError({\n      code: ErrorCode.PROCESS_READY_TIMEOUT,\n      message: `Process did not become ready within ${timeout}ms. Waiting for: ${condition}`,\n      context: {\n        processId,\n        command,\n        condition,\n        timeout\n      },\n      httpStatus: 408,\n      timestamp: new Date().toISOString(),\n      suggestion: `Check if your process outputs ${condition}. You can increase the timeout parameter.`\n    });\n  }\n\n  /**\n   * Create a ProcessExitedBeforeReadyError\n   */\n  private createExitedBeforeReadyError(\n    processId: string,\n    command: string,\n    condition: string,\n    exitCode: number\n  ): ProcessExitedBeforeReadyError {\n    return new ProcessExitedBeforeReadyError({\n      code: ErrorCode.PROCESS_EXITED_BEFORE_READY,\n      message: `Process exited with code ${exitCode} before becoming ready. Waiting for: ${condition}`,\n      context: {\n        processId,\n        command,\n        condition,\n        exitCode\n      },\n      httpStatus: 500,\n      timestamp: new Date().toISOString(),\n      suggestion: 'Check process logs with getLogs() for error messages'\n    });\n  }\n\n  // Background process management\n  async startProcess(\n    command: string,\n    options?: ProcessOptions,\n    sessionId?: string\n  ): Promise<Process> {\n    // Use the new HttpClient method to start the process\n    try {\n      const session = sessionId ?? (await this.ensureDefaultSession());\n      const requestOptions = {\n        ...(options?.processId !== undefined && {\n          processId: options.processId\n        }),\n        ...(options?.timeout !== undefined && { timeoutMs: options.timeout }),\n        ...(options?.env !== undefined && { env: filterEnvVars(options.env) }),\n        ...(options?.cwd !== undefined && { cwd: options.cwd }),\n        ...(options?.encoding !== undefined && { encoding: options.encoding }),\n        ...(options?.autoCleanup !== undefined && {\n          autoCleanup: options.autoCleanup\n        })\n      };\n\n      const response = await this.client.processes.startProcess(\n        command,\n        session,\n        requestOptions\n      );\n\n      const processObj = this.createProcessFromDTO(\n        {\n          id: response.processId,\n          pid: response.pid,\n          command: response.command,\n          status: 'running' as ProcessStatus,\n          startTime: new Date(),\n          endTime: undefined,\n          exitCode: undefined\n        },\n        session\n      );\n\n      // Call onStart callback if provided\n      if (options?.onStart) {\n        options.onStart(processObj);\n      }\n\n      // Start background streaming if output/exit callbacks are provided\n      if (options?.onOutput || options?.onExit) {\n        // Fire and forget - don't await, let it run in background\n        this.startProcessCallbackStream(response.processId, options).catch(\n          () => {\n            // Error already handled in startProcessCallbackStream\n          }\n        );\n      }\n\n      return processObj;\n    } catch (error) {\n      if (options?.onError && error instanceof Error) {\n        options.onError(error);\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Start background streaming for process callbacks\n   * Opens SSE stream to container and routes events to callbacks\n   */\n  private async startProcessCallbackStream(\n    processId: string,\n    options: ProcessOptions\n  ): Promise<void> {\n    try {\n      const stream = await this.client.processes.streamProcessLogs(processId);\n\n      for await (const event of parseSSEStream<{\n        type: string;\n        data?: string;\n        exitCode?: number;\n        processId?: string;\n      }>(stream)) {\n        switch (event.type) {\n          case 'stdout':\n            if (event.data && options.onOutput) {\n              options.onOutput('stdout', event.data);\n            }\n            break;\n          case 'stderr':\n            if (event.data && options.onOutput) {\n              options.onOutput('stderr', event.data);\n            }\n            break;\n          case 'exit':\n          case 'complete':\n            if (options.onExit) {\n              options.onExit(event.exitCode ?? null);\n            }\n            return; // Stream complete\n        }\n      }\n    } catch (error) {\n      // Call onError if streaming fails\n      if (options.onError && error instanceof Error) {\n        options.onError(error);\n      }\n      // Don't rethrow - background streaming failure shouldn't crash the caller\n      this.logger.error(\n        'Background process streaming failed',\n        error instanceof Error ? error : new Error(String(error)),\n        { processId }\n      );\n    }\n  }\n\n  async listProcesses(sessionId?: string): Promise<Process[]> {\n    const session = sessionId ?? (await this.ensureDefaultSession());\n    const response = await this.client.processes.listProcesses();\n\n    return response.processes.map((processData) =>\n      this.createProcessFromDTO(\n        {\n          id: processData.id,\n          pid: processData.pid,\n          command: processData.command,\n          status: processData.status,\n          startTime: processData.startTime,\n          endTime: processData.endTime,\n          exitCode: processData.exitCode\n        },\n        session\n      )\n    );\n  }\n\n  async getProcess(id: string, sessionId?: string): Promise<Process | null> {\n    const session = sessionId ?? (await this.ensureDefaultSession());\n    const response = await this.client.processes.getProcess(id);\n    if (!response.process) {\n      return null;\n    }\n\n    const processData = response.process;\n    return this.createProcessFromDTO(\n      {\n        id: processData.id,\n        pid: processData.pid,\n        command: processData.command,\n        status: processData.status,\n        startTime: processData.startTime,\n        endTime: processData.endTime,\n        exitCode: processData.exitCode\n      },\n      session\n    );\n  }\n\n  async killProcess(\n    id: string,\n    signal?: string,\n    sessionId?: string\n  ): Promise<void> {\n    // Note: signal parameter is not currently supported by the HTTP client\n    await this.client.processes.killProcess(id);\n  }\n\n  async killAllProcesses(sessionId?: string): Promise<number> {\n    const response = await this.client.processes.killAllProcesses();\n    return response.cleanedCount;\n  }\n\n  async cleanupCompletedProcesses(sessionId?: string): Promise<number> {\n    // Not yet implemented - requires container endpoint\n    return 0;\n  }\n\n  async getProcessLogs(\n    id: string,\n    sessionId?: string\n  ): Promise<{ stdout: string; stderr: string; processId: string }> {\n    const response = await this.client.processes.getProcessLogs(id);\n    return {\n      stdout: response.stdout,\n      stderr: response.stderr,\n      processId: response.processId\n    };\n  }\n\n  // Streaming methods - return ReadableStream for RPC compatibility\n  async execStream(\n    command: string,\n    options?: StreamOptions\n  ): Promise<ReadableStream<Uint8Array>> {\n    // Check for cancellation\n    if (options?.signal?.aborted) {\n      throw new Error('Operation was aborted');\n    }\n\n    const session = await this.ensureDefaultSession();\n    // Get the stream from CommandClient\n    return this.client.commands.executeStream(command, session, {\n      timeoutMs: options?.timeout,\n      env: options?.env,\n      cwd: options?.cwd\n    });\n  }\n\n  /**\n   * Internal session-aware execStream implementation\n   */\n  private async execStreamWithSession(\n    command: string,\n    sessionId: string,\n    options?: StreamOptions\n  ): Promise<ReadableStream<Uint8Array>> {\n    // Check for cancellation\n    if (options?.signal?.aborted) {\n      throw new Error('Operation was aborted');\n    }\n\n    return this.client.commands.executeStream(command, sessionId, {\n      timeoutMs: options?.timeout,\n      env: options?.env,\n      cwd: options?.cwd\n    });\n  }\n\n  /**\n   * Stream logs from a background process as a ReadableStream.\n   */\n  async streamProcessLogs(\n    processId: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<ReadableStream<Uint8Array>> {\n    // Check for cancellation\n    if (options?.signal?.aborted) {\n      throw new Error('Operation was aborted');\n    }\n\n    return this.client.processes.streamProcessLogs(processId);\n  }\n\n  async gitCheckout(\n    repoUrl: string,\n    options?: {\n      branch?: string;\n      targetDir?: string;\n      sessionId?: string;\n      /** Clone depth for shallow clones (e.g., 1 for latest commit only) */\n      depth?: number;\n    }\n  ) {\n    const session = options?.sessionId ?? (await this.ensureDefaultSession());\n    return this.client.git.checkout(repoUrl, session, {\n      branch: options?.branch,\n      targetDir: options?.targetDir,\n      depth: options?.depth\n    });\n  }\n\n  async mkdir(\n    path: string,\n    options: { recursive?: boolean; sessionId?: string } = {}\n  ) {\n    const session = options.sessionId ?? (await this.ensureDefaultSession());\n    return this.client.files.mkdir(path, session, {\n      recursive: options.recursive\n    });\n  }\n\n  async writeFile(\n    path: string,\n    content: string,\n    options: { encoding?: string; sessionId?: string } = {}\n  ) {\n    const session = options.sessionId ?? (await this.ensureDefaultSession());\n    return this.client.files.writeFile(path, content, session, {\n      encoding: options.encoding\n    });\n  }\n\n  async deleteFile(path: string, sessionId?: string) {\n    const session = sessionId ?? (await this.ensureDefaultSession());\n    return this.client.files.deleteFile(path, session);\n  }\n\n  async renameFile(oldPath: string, newPath: string, sessionId?: string) {\n    const session = sessionId ?? (await this.ensureDefaultSession());\n    return this.client.files.renameFile(oldPath, newPath, session);\n  }\n\n  async moveFile(\n    sourcePath: string,\n    destinationPath: string,\n    sessionId?: string\n  ) {\n    const session = sessionId ?? (await this.ensureDefaultSession());\n    return this.client.files.moveFile(sourcePath, destinationPath, session);\n  }\n\n  async readFile(\n    path: string,\n    options: { encoding?: string; sessionId?: string } = {}\n  ) {\n    const session = options.sessionId ?? (await this.ensureDefaultSession());\n    return this.client.files.readFile(path, session, {\n      encoding: options.encoding\n    });\n  }\n\n  /**\n   * Stream a file from the sandbox using Server-Sent Events\n   * Returns a ReadableStream that can be consumed with streamFile() or collectFile() utilities\n   * @param path - Path to the file to stream\n   * @param options - Optional session ID\n   */\n  async readFileStream(\n    path: string,\n    options: { sessionId?: string } = {}\n  ): Promise<ReadableStream<Uint8Array>> {\n    const session = options.sessionId ?? (await this.ensureDefaultSession());\n    return this.client.files.readFileStream(path, session);\n  }\n\n  async listFiles(\n    path: string,\n    options?: { recursive?: boolean; includeHidden?: boolean }\n  ) {\n    const session = await this.ensureDefaultSession();\n    return this.client.files.listFiles(path, session, options);\n  }\n\n  async exists(path: string, sessionId?: string) {\n    const session = sessionId ?? (await this.ensureDefaultSession());\n    return this.client.files.exists(path, session);\n  }\n\n  /**\n   * Expose a port and get a preview URL for accessing services running in the sandbox\n   *\n   * @param port - Port number to expose (1024-65535)\n   * @param options - Configuration options\n   * @param options.hostname - Your Worker's domain name (required for preview URL construction)\n   * @param options.name - Optional friendly name for the port\n   * @param options.token - Optional custom token for the preview URL (1-16 characters: lowercase letters, numbers, hyphens, underscores)\n   *                       If not provided, a random 16-character token will be generated automatically\n   * @returns Preview URL information including the full URL, port number, and optional name\n   *\n   * @example\n   * // With auto-generated token\n   * const { url } = await sandbox.exposePort(8080, { hostname: 'example.com' });\n   * // url: https://8080-sandbox-id-abc123random4567.example.com\n   *\n   * @example\n   * // With custom token for stable URLs across deployments\n   * const { url } = await sandbox.exposePort(8080, {\n   *   hostname: 'example.com',\n   *   token: 'my-token-v1'\n   * });\n   * // url: https://8080-sandbox-id-my-token-v1.example.com\n   */\n  async exposePort(\n    port: number,\n    options: { name?: string; hostname: string; token?: string }\n  ) {\n    // Check if hostname is workers.dev domain (doesn't support wildcard subdomains)\n    if (options.hostname.endsWith('.workers.dev')) {\n      const errorResponse: ErrorResponse = {\n        code: ErrorCode.CUSTOM_DOMAIN_REQUIRED,\n        message: `Port exposure requires a custom domain. .workers.dev domains do not support wildcard subdomains required for port proxying.`,\n        context: { originalError: options.hostname },\n        httpStatus: 400,\n        timestamp: new Date().toISOString()\n      };\n      throw new CustomDomainRequiredError(errorResponse);\n    }\n\n    // We need the sandbox name to construct preview URLs\n    if (!this.sandboxName) {\n      throw new Error(\n        'Sandbox name not available. Ensure sandbox is accessed through getSandbox()'\n      );\n    }\n\n    let token: string;\n    if (options.token !== undefined) {\n      this.validateCustomToken(options.token);\n      token = options.token;\n    } else {\n      token = this.generatePortToken();\n    }\n\n    // Allow re-exposing same port with same token, but reject if another port uses this token\n    const tokens =\n      (await this.ctx.storage.get<Record<string, string>>('portTokens')) || {};\n    const existingPort = Object.entries(tokens).find(\n      ([p, t]) => t === token && p !== port.toString()\n    );\n    if (existingPort) {\n      throw new SecurityError(\n        `Token '${token}' is already in use by port ${existingPort[0]}. Please use a different token.`\n      );\n    }\n\n    const sessionId = await this.ensureDefaultSession();\n    await this.client.ports.exposePort(port, sessionId, options?.name);\n\n    tokens[port.toString()] = token;\n    await this.ctx.storage.put('portTokens', tokens);\n\n    const url = this.constructPreviewUrl(\n      port,\n      this.sandboxName,\n      options.hostname,\n      token\n    );\n\n    return {\n      url,\n      port,\n      name: options?.name\n    };\n  }\n\n  async unexposePort(port: number) {\n    if (!validatePort(port)) {\n      throw new SecurityError(\n        `Invalid port number: ${port}. Must be between 1024-65535 and not reserved.`\n      );\n    }\n\n    const sessionId = await this.ensureDefaultSession();\n    await this.client.ports.unexposePort(port, sessionId);\n\n    // Clean up token for this port (storage is protected by input gates)\n    const tokens =\n      (await this.ctx.storage.get<Record<string, string>>('portTokens')) || {};\n    if (tokens[port.toString()]) {\n      delete tokens[port.toString()];\n      await this.ctx.storage.put('portTokens', tokens);\n    }\n  }\n\n  async getExposedPorts(hostname: string) {\n    const sessionId = await this.ensureDefaultSession();\n    const response = await this.client.ports.getExposedPorts(sessionId);\n\n    // We need the sandbox name to construct preview URLs\n    if (!this.sandboxName) {\n      throw new Error(\n        'Sandbox name not available. Ensure sandbox is accessed through getSandbox()'\n      );\n    }\n\n    // Read all tokens from storage (protected by input gates)\n    const tokens =\n      (await this.ctx.storage.get<Record<string, string>>('portTokens')) || {};\n\n    return response.ports.map((port) => {\n      const token = tokens[port.port.toString()];\n      if (!token) {\n        throw new Error(\n          `Port ${port.port} is exposed but has no token. This should not happen.`\n        );\n      }\n\n      return {\n        url: this.constructPreviewUrl(\n          port.port,\n          this.sandboxName!,\n          hostname,\n          token\n        ),\n        port: port.port,\n        status: port.status\n      };\n    });\n  }\n\n  async isPortExposed(port: number): Promise<boolean> {\n    try {\n      const sessionId = await this.ensureDefaultSession();\n      const response = await this.client.ports.getExposedPorts(sessionId);\n      return response.ports.some((exposedPort) => exposedPort.port === port);\n    } catch (error) {\n      this.logger.error(\n        'Error checking if port is exposed',\n        error instanceof Error ? error : new Error(String(error)),\n        { port }\n      );\n      return false;\n    }\n  }\n\n  async validatePortToken(port: number, token: string): Promise<boolean> {\n    // First check if port is exposed\n    const isExposed = await this.isPortExposed(port);\n    if (!isExposed) {\n      return false;\n    }\n\n    // Read stored token from storage (protected by input gates)\n    const tokens =\n      (await this.ctx.storage.get<Record<string, string>>('portTokens')) || {};\n    const storedToken = tokens[port.toString()];\n    if (!storedToken) {\n      this.logger.error(\n        'Port is exposed but has no token - bug detected',\n        undefined,\n        { port }\n      );\n      return false;\n    }\n\n    if (storedToken.length !== token.length) {\n      return false;\n    }\n\n    const encoder = new TextEncoder();\n    const a = encoder.encode(storedToken);\n    const b = encoder.encode(token);\n\n    return crypto.subtle.timingSafeEqual(a, b);\n  }\n\n  private validateCustomToken(token: string): void {\n    if (token.length === 0) {\n      throw new SecurityError(`Custom token cannot be empty.`);\n    }\n\n    if (token.length > 16) {\n      throw new SecurityError(\n        `Custom token too long. Maximum 16 characters allowed. Received: ${token.length} characters.`\n      );\n    }\n\n    if (!/^[a-z0-9_]+$/.test(token)) {\n      throw new SecurityError(\n        `Custom token must contain only lowercase letters (a-z), numbers (0-9), and underscores (_). Invalid token provided.`\n      );\n    }\n  }\n\n  private generatePortToken(): string {\n    // Generate cryptographically secure 16-character token using Web Crypto API\n    // Available in Cloudflare Workers runtime\n    const array = new Uint8Array(12); // 12 bytes = 16 base64url chars (after padding removal)\n    crypto.getRandomValues(array);\n\n    const base64 = btoa(String.fromCharCode(...array));\n    return base64\n      .replace(/\\+/g, '_')\n      .replace(/\\//g, '_')\n      .replace(/=/g, '')\n      .toLowerCase();\n  }\n\n  private constructPreviewUrl(\n    port: number,\n    sandboxId: string,\n    hostname: string,\n    token: string\n  ): string {\n    if (!validatePort(port)) {\n      throw new SecurityError(\n        `Invalid port number: ${port}. Must be between 1024-65535 and not reserved.`\n      );\n    }\n\n    // Hostnames are case-insensitive, routing requests to wrong DO instance when keys contain uppercase letters\n    const effectiveId = this.sandboxName || sandboxId;\n    const hasUppercase = /[A-Z]/.test(effectiveId);\n    if (!this.normalizeId && hasUppercase) {\n      throw new SecurityError(\n        `Preview URLs require lowercase sandbox IDs. Your ID \"${effectiveId}\" contains uppercase letters.\\n\\n` +\n          `To fix this:\\n` +\n          `1. Create a new sandbox with: getSandbox(ns, \"${effectiveId}\", { normalizeId: true })\\n` +\n          `2. This will create a sandbox with ID: \"${effectiveId.toLowerCase()}\"\\n\\n` +\n          `Note: Due to DNS case-insensitivity, IDs with uppercase letters cannot be used with preview URLs.`\n      );\n    }\n\n    const sanitizedSandboxId = sanitizeSandboxId(sandboxId).toLowerCase();\n\n    const isLocalhost = isLocalhostPattern(hostname);\n\n    if (isLocalhost) {\n      const [host, portStr] = hostname.split(':');\n      const mainPort = portStr || '80';\n\n      try {\n        const baseUrl = new URL(`http://${host}:${mainPort}`);\n        const subdomainHost = `${port}-${sanitizedSandboxId}-${token}.${host}`;\n        baseUrl.hostname = subdomainHost;\n\n        return baseUrl.toString();\n      } catch (error) {\n        throw new SecurityError(\n          `Failed to construct preview URL: ${\n            error instanceof Error ? error.message : 'Unknown error'\n          }`\n        );\n      }\n    }\n\n    try {\n      const baseUrl = new URL(`https://${hostname}`);\n      const subdomainHost = `${port}-${sanitizedSandboxId}-${token}.${hostname}`;\n      baseUrl.hostname = subdomainHost;\n\n      return baseUrl.toString();\n    } catch (error) {\n      throw new SecurityError(\n        `Failed to construct preview URL: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      );\n    }\n  }\n\n  // ============================================================================\n  // Session Management - Advanced Use Cases\n  // ============================================================================\n\n  /**\n   * Create isolated execution session for advanced use cases\n   * Returns ExecutionSession with full sandbox API bound to specific session\n   */\n  async createSession(options?: SessionOptions): Promise<ExecutionSession> {\n    const sessionId = options?.id || `session-${Date.now()}`;\n\n    const mergedEnv = {\n      ...this.envVars,\n      ...(options?.env ?? {})\n    };\n    const filteredEnv = filterEnvVars(mergedEnv);\n    const envPayload =\n      Object.keys(filteredEnv).length > 0 ? filteredEnv : undefined;\n\n    // Create session in container\n    await this.client.utils.createSession({\n      id: sessionId,\n      ...(envPayload && { env: envPayload }),\n      ...(options?.cwd && { cwd: options.cwd })\n    });\n\n    // Return wrapper that binds sessionId to all operations\n    return this.getSessionWrapper(sessionId);\n  }\n\n  /**\n   * Get an existing session by ID\n   * Returns ExecutionSession wrapper bound to the specified session\n   *\n   * This is useful for retrieving sessions across different requests/contexts\n   * without storing the ExecutionSession object (which has RPC lifecycle limitations)\n   *\n   * @param sessionId - The ID of an existing session\n   * @returns ExecutionSession wrapper bound to the session\n   */\n  async getSession(sessionId: string): Promise<ExecutionSession> {\n    // No need to verify session exists in container - operations will fail naturally if it doesn't\n    return this.getSessionWrapper(sessionId);\n  }\n\n  /**\n   * Delete an execution session\n   * Cleans up session resources and removes it from the container\n   * Note: Cannot delete the default session. To reset the default session,\n   * use sandbox.destroy() to terminate the entire sandbox.\n   *\n   * @param sessionId - The ID of the session to delete\n   * @returns Result with success status, sessionId, and timestamp\n   * @throws Error if attempting to delete the default session\n   */\n  async deleteSession(sessionId: string): Promise<SessionDeleteResult> {\n    // Prevent deletion of default session\n    if (this.defaultSession && sessionId === this.defaultSession) {\n      throw new Error(\n        `Cannot delete default session '${sessionId}'. Use sandbox.destroy() to terminate the sandbox.`\n      );\n    }\n\n    const response = await this.client.utils.deleteSession(sessionId);\n\n    // Map HTTP response to result type\n    return {\n      success: response.success,\n      sessionId: response.sessionId,\n      timestamp: response.timestamp\n    };\n  }\n\n  /**\n   * Internal helper to create ExecutionSession wrapper for a given sessionId\n   * Used by both createSession and getSession\n   */\n  private getSessionWrapper(sessionId: string): ExecutionSession {\n    return {\n      id: sessionId,\n\n      // Command execution - delegate to internal session-aware methods\n      exec: (command, options) =>\n        this.execWithSession(command, sessionId, options),\n      execStream: (command, options) =>\n        this.execStreamWithSession(command, sessionId, options),\n\n      // Process management\n      startProcess: (command, options) =>\n        this.startProcess(command, options, sessionId),\n      listProcesses: () => this.listProcesses(sessionId),\n      getProcess: (id) => this.getProcess(id, sessionId),\n      killProcess: (id, signal) => this.killProcess(id, signal),\n      killAllProcesses: () => this.killAllProcesses(),\n      cleanupCompletedProcesses: () => this.cleanupCompletedProcesses(),\n      getProcessLogs: (id) => this.getProcessLogs(id),\n      streamProcessLogs: (processId, options) =>\n        this.streamProcessLogs(processId, options),\n\n      // File operations - pass sessionId via options or parameter\n      writeFile: (path, content, options) =>\n        this.writeFile(path, content, { ...options, sessionId }),\n      readFile: (path, options) =>\n        this.readFile(path, { ...options, sessionId }),\n      readFileStream: (path) => this.readFileStream(path, { sessionId }),\n      mkdir: (path, options) => this.mkdir(path, { ...options, sessionId }),\n      deleteFile: (path) => this.deleteFile(path, sessionId),\n      renameFile: (oldPath, newPath) =>\n        this.renameFile(oldPath, newPath, sessionId),\n      moveFile: (sourcePath, destPath) =>\n        this.moveFile(sourcePath, destPath, sessionId),\n      listFiles: (path, options) =>\n        this.client.files.listFiles(path, sessionId, options),\n      exists: (path) => this.exists(path, sessionId),\n\n      // Git operations\n      gitCheckout: (repoUrl, options) =>\n        this.gitCheckout(repoUrl, { ...options, sessionId }),\n\n      setEnvVars: async (envVars: Record<string, string | undefined>) => {\n        const { toSet, toUnset } = partitionEnvVars(envVars);\n\n        try {\n          for (const key of toUnset) {\n            const unsetCommand = `unset ${key}`;\n\n            const result = await this.client.commands.execute(\n              unsetCommand,\n              sessionId\n            );\n\n            if (result.exitCode !== 0) {\n              throw new Error(\n                `Failed to unset ${key}: ${result.stderr || 'Unknown error'}`\n              );\n            }\n          }\n\n          for (const [key, value] of Object.entries(toSet)) {\n            const exportCommand = `export ${key}=${shellEscape(value)}`;\n\n            const result = await this.client.commands.execute(\n              exportCommand,\n              sessionId\n            );\n\n            if (result.exitCode !== 0) {\n              throw new Error(\n                `Failed to set ${key}: ${result.stderr || 'Unknown error'}`\n              );\n            }\n          }\n        } catch (error) {\n          this.logger.error(\n            'Failed to set environment variables',\n            error instanceof Error ? error : new Error(String(error)),\n            { sessionId }\n          );\n          throw error;\n        }\n      },\n\n      // Code interpreter methods - delegate to sandbox's code interpreter\n      createCodeContext: (options) =>\n        this.codeInterpreter.createCodeContext(options),\n      runCode: async (code, options) => {\n        const execution = await this.codeInterpreter.runCode(code, options);\n        return execution.toJSON();\n      },\n      runCodeStream: (code, options) =>\n        this.codeInterpreter.runCodeStream(code, options),\n      listCodeContexts: () => this.codeInterpreter.listCodeContexts(),\n      deleteCodeContext: (contextId) =>\n        this.codeInterpreter.deleteCodeContext(contextId),\n\n      // Bucket mounting - sandbox-level operations\n      mountBucket: (bucket, mountPath, options) =>\n        this.mountBucket(bucket, mountPath, options),\n      unmountBucket: (mountPath) => this.unmountBucket(mountPath)\n    };\n  }\n\n  // ============================================================================\n  // Code interpreter methods - delegate to CodeInterpreter wrapper\n  // ============================================================================\n\n  async createCodeContext(\n    options?: CreateContextOptions\n  ): Promise<CodeContext> {\n    return this.codeInterpreter.createCodeContext(options);\n  }\n\n  async runCode(\n    code: string,\n    options?: RunCodeOptions\n  ): Promise<ExecutionResult> {\n    const execution = await this.codeInterpreter.runCode(code, options);\n    return execution.toJSON();\n  }\n\n  async runCodeStream(\n    code: string,\n    options?: RunCodeOptions\n  ): Promise<ReadableStream> {\n    return this.codeInterpreter.runCodeStream(code, options);\n  }\n\n  async listCodeContexts(): Promise<CodeContext[]> {\n    return this.codeInterpreter.listCodeContexts();\n  }\n\n  async deleteCodeContext(contextId: string): Promise<void> {\n    return this.codeInterpreter.deleteCodeContext(contextId);\n  }\n}\n", "import type { FileChunk, FileMetadata, FileStreamEvent } from '@repo/shared';\n\n/**\n * Parse SSE (Server-Sent Events) lines from a stream\n */\nasync function* parseSSE(\n  stream: ReadableStream<Uint8Array>\n): AsyncGenerator<FileStreamEvent> {\n  const reader = stream.getReader();\n  const decoder = new TextDecoder();\n  let buffer = '';\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (done) {\n        break;\n      }\n\n      buffer += decoder.decode(value, { stream: true });\n      const lines = buffer.split('\\n');\n\n      // Keep the last incomplete line in the buffer\n      buffer = lines.pop() || '';\n\n      for (const line of lines) {\n        if (line.startsWith('data: ')) {\n          const data = line.slice(6); // Remove 'data: ' prefix\n          try {\n            const event = JSON.parse(data) as FileStreamEvent;\n            yield event;\n          } catch {\n            // Skip invalid JSON events and continue processing\n          }\n        }\n      }\n    }\n  } finally {\n    // Cancel the stream first to properly terminate HTTP connections when breaking early\n    try {\n      await reader.cancel();\n    } catch {\n      // Ignore cancel errors (stream may already be closed)\n    }\n    reader.releaseLock();\n  }\n}\n\n/**\n * Stream a file from the sandbox with automatic base64 decoding for binary files\n *\n * @param stream - The ReadableStream from readFileStream()\n * @returns AsyncGenerator that yields FileChunk (string for text, Uint8Array for binary)\n *\n * @example\n * ```ts\n * const stream = await sandbox.readFileStream('/path/to/file.png');\n * for await (const chunk of streamFile(stream)) {\n *   if (chunk instanceof Uint8Array) {\n *     // Binary chunk\n *     console.log('Binary chunk:', chunk.length, 'bytes');\n *   } else {\n *     // Text chunk\n *     console.log('Text chunk:', chunk);\n *   }\n * }\n * ```\n */\nexport async function* streamFile(\n  stream: ReadableStream<Uint8Array>\n): AsyncGenerator<FileChunk, FileMetadata> {\n  let metadata: FileMetadata | null = null;\n\n  for await (const event of parseSSE(stream)) {\n    switch (event.type) {\n      case 'metadata':\n        metadata = {\n          mimeType: event.mimeType,\n          size: event.size,\n          isBinary: event.isBinary,\n          encoding: event.encoding\n        };\n        break;\n\n      case 'chunk':\n        if (!metadata) {\n          throw new Error('Received chunk before metadata');\n        }\n\n        if (metadata.isBinary && metadata.encoding === 'base64') {\n          // Decode base64 to Uint8Array for binary files\n          const binaryString = atob(event.data);\n          const bytes = new Uint8Array(binaryString.length);\n          for (let i = 0; i < binaryString.length; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n          }\n          yield bytes;\n        } else {\n          // Text files - yield as-is\n          yield event.data;\n        }\n        break;\n\n      case 'complete':\n        if (!metadata) {\n          throw new Error('Stream completed without metadata');\n        }\n        return metadata;\n\n      case 'error':\n        throw new Error(`File streaming error: ${event.error}`);\n    }\n  }\n\n  throw new Error('Stream ended unexpectedly');\n}\n\n/**\n * Collect an entire file into memory from a stream\n *\n * @param stream - The ReadableStream from readFileStream()\n * @returns Object containing the file content and metadata\n *\n * @example\n * ```ts\n * const stream = await sandbox.readFileStream('/path/to/file.txt');\n * const { content, metadata } = await collectFile(stream);\n * console.log('Content:', content);\n * console.log('MIME type:', metadata.mimeType);\n * ```\n */\nexport async function collectFile(stream: ReadableStream<Uint8Array>): Promise<{\n  content: string | Uint8Array;\n  metadata: FileMetadata;\n}> {\n  const chunks: Array<string | Uint8Array> = [];\n\n  // Iterate through the generator and get the return value (metadata)\n  const generator = streamFile(stream);\n  let result = await generator.next();\n\n  while (!result.done) {\n    chunks.push(result.value);\n    result = await generator.next();\n  }\n\n  const metadata = result.value;\n\n  if (!metadata) {\n    throw new Error('Failed to get file metadata');\n  }\n\n  // Combine chunks based on type\n  if (metadata.isBinary) {\n    // Binary file - combine Uint8Arrays\n    const totalLength = chunks.reduce(\n      (sum, chunk) => sum + (chunk instanceof Uint8Array ? chunk.length : 0),\n      0\n    );\n    const combined = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks) {\n      if (chunk instanceof Uint8Array) {\n        combined.set(chunk, offset);\n        offset += chunk.length;\n      }\n    }\n    return { content: combined, metadata };\n  } else {\n    // Text file - combine strings\n    const combined = chunks.filter((c) => typeof c === 'string').join('');\n    return { content: combined, metadata };\n  }\n}\n", "const r=Object.create(null),i=e=>globalThis.process?.env||import.meta.env||globalThis.Deno?.env.toObject()||globalThis.__env__||(e?r:globalThis),o=new Proxy(r,{get(e,s){return i()[s]??r[s]},has(e,s){const E=i();return s in E||s in r},set(e,s,E){const B=i(!0);return B[s]=E,!0},deleteProperty(e,s){if(!s)return!1;const E=i(!0);return delete E[s],!0},ownKeys(){const e=i(!0);return Object.keys(e)}}),t=typeof process<\"u\"&&process.env&&process.env.NODE_ENV||\"\",f=[[\"APPVEYOR\"],[\"AWS_AMPLIFY\",\"AWS_APP_ID\",{ci:!0}],[\"AZURE_PIPELINES\",\"SYSTEM_TEAMFOUNDATIONCOLLECTIONURI\"],[\"AZURE_STATIC\",\"INPUT_AZURE_STATIC_WEB_APPS_API_TOKEN\"],[\"APPCIRCLE\",\"AC_APPCIRCLE\"],[\"BAMBOO\",\"bamboo_planKey\"],[\"BITBUCKET\",\"BITBUCKET_COMMIT\"],[\"BITRISE\",\"BITRISE_IO\"],[\"BUDDY\",\"BUDDY_WORKSPACE_ID\"],[\"BUILDKITE\"],[\"CIRCLE\",\"CIRCLECI\"],[\"CIRRUS\",\"CIRRUS_CI\"],[\"CLOUDFLARE_PAGES\",\"CF_PAGES\",{ci:!0}],[\"CLOUDFLARE_WORKERS\",\"WORKERS_CI\",{ci:!0}],[\"CODEBUILD\",\"CODEBUILD_BUILD_ARN\"],[\"CODEFRESH\",\"CF_BUILD_ID\"],[\"DRONE\"],[\"DRONE\",\"DRONE_BUILD_EVENT\"],[\"DSARI\"],[\"GITHUB_ACTIONS\"],[\"GITLAB\",\"GITLAB_CI\"],[\"GITLAB\",\"CI_MERGE_REQUEST_ID\"],[\"GOCD\",\"GO_PIPELINE_LABEL\"],[\"LAYERCI\"],[\"HUDSON\",\"HUDSON_URL\"],[\"JENKINS\",\"JENKINS_URL\"],[\"MAGNUM\"],[\"NETLIFY\"],[\"NETLIFY\",\"NETLIFY_LOCAL\",{ci:!1}],[\"NEVERCODE\"],[\"RENDER\"],[\"SAIL\",\"SAILCI\"],[\"SEMAPHORE\"],[\"SCREWDRIVER\"],[\"SHIPPABLE\"],[\"SOLANO\",\"TDDIUM\"],[\"STRIDER\"],[\"TEAMCITY\",\"TEAMCITY_VERSION\"],[\"TRAVIS\"],[\"VERCEL\",\"NOW_BUILDER\"],[\"VERCEL\",\"VERCEL\",{ci:!1}],[\"VERCEL\",\"VERCEL_ENV\",{ci:!1}],[\"APPCENTER\",\"APPCENTER_BUILD_ID\"],[\"CODESANDBOX\",\"CODESANDBOX_SSE\",{ci:!1}],[\"CODESANDBOX\",\"CODESANDBOX_HOST\",{ci:!1}],[\"STACKBLITZ\"],[\"STORMKIT\"],[\"CLEAVR\"],[\"ZEABUR\"],[\"CODESPHERE\",\"CODESPHERE_APP_ID\",{ci:!0}],[\"RAILWAY\",\"RAILWAY_PROJECT_ID\"],[\"RAILWAY\",\"RAILWAY_SERVICE_ID\"],[\"DENO-DEPLOY\",\"DENO_DEPLOYMENT_ID\"],[\"FIREBASE_APP_HOSTING\",\"FIREBASE_APP_HOSTING\",{ci:!0}]];function b(){if(globalThis.process?.env)for(const e of f){const s=e[1]||e[0];if(globalThis.process?.env[s])return{name:e[0].toLowerCase(),...e[2]}}return globalThis.process?.env?.SHELL===\"/bin/jsh\"&&globalThis.process?.versions?.webcontainer?{name:\"stackblitz\",ci:!1}:{name:\"\",ci:!1}}const l=b(),p=l.name;function n(e){return e?e!==\"false\":!1}const I=globalThis.process?.platform||\"\",T=n(o.CI)||l.ci!==!1,R=n(globalThis.process?.stdout&&globalThis.process?.stdout.isTTY),U=typeof window<\"u\",d=n(o.DEBUG),a=t===\"test\"||n(o.TEST),g=t===\"production\",h=t===\"dev\"||t===\"development\",v=n(o.MINIMAL)||T||a||!R,A=/^win/i.test(I),M=/^linux/i.test(I),m=/^darwin/i.test(I),Y=!n(o.NO_COLOR)&&(n(o.FORCE_COLOR)||(R||A)&&o.TERM!==\"dumb\"||T),C=(globalThis.process?.versions?.node||\"\").replace(/^v/,\"\")||null,V=Number(C?.split(\".\")[0])||null,W=globalThis.process||Object.create(null),_={versions:{}},y=new Proxy(W,{get(e,s){if(s===\"env\")return o;if(s in e)return e[s];if(s in _)return _[s]}}),O=globalThis.process?.release?.name===\"node\",c=!!globalThis.Bun||!!globalThis.process?.versions?.bun,D=!!globalThis.Deno,L=!!globalThis.fastly,S=!!globalThis.Netlify,u=!!globalThis.EdgeRuntime,N=globalThis.navigator?.userAgent===\"Cloudflare-Workers\",F=[[S,\"netlify\"],[u,\"edge-light\"],[N,\"workerd\"],[L,\"fastly\"],[D,\"deno\"],[c,\"bun\"],[O,\"node\"]];function G(){const e=F.find(s=>s[0]);if(e)return{name:e[1]}}const P=G(),K=P?.name||\"\";export{o as env,R as hasTTY,U as hasWindow,c as isBun,T as isCI,Y as isColorSupported,d as isDebug,D as isDeno,h as isDevelopment,u as isEdgeLight,L as isFastly,M as isLinux,m as isMacOS,v as isMinimal,S as isNetlify,O as isNode,g as isProduction,a as isTest,A as isWindows,N as isWorkerd,t as nodeENV,V as nodeMajorVersion,C as nodeVersion,I as platform,y as process,p as provider,l as providerInfo,K as runtime,P as runtimeInfo};\n", "import type { CloudflareSandboxStub, Sandbox, SandboxExecResult, SandboxProvider } from './types'\n\nfunction shellQuote(arg: string): string {\n  if (!/[^\\w\\-./=]/.test(arg))\n    return arg\n  return `'${arg.replace(/'/g, `'\\\\''`)}'`\n}\n\nexport class CloudflareSandboxAdapter implements Sandbox {\n  id: string\n  provider: SandboxProvider = 'cloudflare'\n  private stub: CloudflareSandboxStub\n\n  constructor(id: string, stub: CloudflareSandboxStub) {\n    this.id = id\n    this.stub = stub\n  }\n\n  async exec(command: string, args: string[]): Promise<SandboxExecResult> {\n    const cmd = args.length ? `${shellQuote(command)} ${args.map(shellQuote).join(' ')}` : shellQuote(command)\n    const result = await this.stub.exec(cmd)\n    return { ok: result.success, stdout: result.stdout, stderr: result.stderr, code: result.exitCode }\n  }\n\n  async writeFile(path: string, content: string): Promise<void> {\n    const result = await this.stub.writeFile(path, content)\n    if (!result.success)\n      throw new Error(`Failed to write file: ${path}`)\n  }\n\n  async readFile(path: string): Promise<string> {\n    const result = await this.stub.readFile(path)\n    if (!result.success)\n      throw new Error(`Failed to read file: ${path}`)\n    return result.content\n  }\n\n  async stop(): Promise<void> {\n    await this.stub.destroy()\n  }\n}\n", "import { isWorkerd, provider as envProvider } from 'std-env'\nimport { CloudflareSandboxAdapter } from './adapters'\nimport type {\n  CloudflareSandboxOptions,\n  DurableObjectNamespaceLike,\n  Sandbox,\n  SandboxExecResult,\n  SandboxOptions,\n  SandboxProvider,\n} from './types'\n\nexport type { CloudflareSandboxOptions, DurableObjectNamespaceLike, Sandbox, SandboxExecResult, SandboxOptions, SandboxProvider } from './types'\n\nasync function loadVercelSandbox(): Promise<unknown> {\n  const moduleName = '@vercel/sandbox'\n  try {\n    return await import(moduleName)\n  }\n  catch (e) {\n    throw new Error(`${moduleName} load failed. Install it to use the Vercel provider. Original error: ${e instanceof Error ? e.message : e}`)\n  }\n}\n\nasync function loadCloudflareSandbox(): Promise<unknown> {\n  const moduleName = '@cloudflare/sandbox'\n  try {\n    return await import(moduleName)\n  }\n  catch (e) {\n    throw new Error(`${moduleName} load failed. Install it to use the Cloudflare provider. Original error: ${e instanceof Error ? e.message : e}`)\n  }\n}\n\n// Vercel Sandbox v1.x types\ninterface VercelSandboxInstance {\n  runCommand: (cmd: string, args: string[]) => Promise<{ exitCode: number, stdout: () => Promise<string>, stderr: () => Promise<string> }>\n  writeFiles: (files: Array<{ path: string, content: Uint8Array }>) => Promise<void>\n  readFileToBuffer: (opts: { path: string }) => Promise<Uint8Array>\n  [Symbol.asyncDispose]: () => Promise<void>\n}\n\ninterface VercelSandboxSDK {\n  Sandbox: {\n    create: (options: { runtime: string, timeoutMs?: number, resources?: { vcpus?: number } }) => Promise<VercelSandboxInstance>\n  }\n}\n\n// Cloudflare Sandbox SDK types (matches @cloudflare/sandbox v0.7+)\ninterface CloudflareSandboxSDK {\n  getSandbox: <T extends CloudflareSandboxStub>(ns: DurableObjectNamespaceLike, id: string, opts?: CloudflareSandboxOptions) => T\n  Sandbox: new (...args: unknown[]) => unknown\n}\n\nclass VercelSandbox implements Sandbox {\n  id: string\n  provider: SandboxProvider = 'vercel'\n  private instance: VercelSandboxInstance\n\n  constructor(id: string, instance: VercelSandboxInstance) {\n    this.id = id\n    this.instance = instance\n  }\n\n  async exec(command: string, args: string[]): Promise<SandboxExecResult> {\n    const result = await this.instance.runCommand(command, args)\n    const [stdout, stderr] = await Promise.all([result.stdout(), result.stderr()])\n    return { ok: result.exitCode === 0, stdout, stderr, code: result.exitCode }\n  }\n\n  async writeFile(path: string, content: string): Promise<void> {\n    await this.instance.writeFiles([{ path, content: Buffer.from(content) }])\n  }\n\n  async readFile(path: string): Promise<string> {\n    const buffer = await this.instance.readFileToBuffer({ path })\n    return Buffer.from(buffer).toString()\n  }\n\n  async stop(): Promise<void> {\n    await this.instance[Symbol.asyncDispose]()\n  }\n}\n\nexport async function createSandbox(options: SandboxOptions = {}): Promise<Sandbox> {\n  const resolved = resolveProvider(options.provider)\n\n  if (resolved.name === 'vercel') {\n    const id = `vercel-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`\n    const { runtime, timeout, cpu } = resolved\n    const sdk = await loadVercelSandbox() as VercelSandboxSDK\n    const instance = await sdk.Sandbox.create({\n      runtime: runtime ?? 'node24',\n      timeoutMs: timeout ?? 300_000,\n      ...(cpu && { resources: { vcpus: cpu } }),\n    })\n    return new VercelSandbox(id, instance)\n  }\n\n  if (resolved.name === 'cloudflare') {\n    if (!resolved.namespace)\n      throw new Error('Cloudflare sandbox requires a Durable Objects binding. Pass { provider: { name: \\'cloudflare\\', namespace } }.')\n\n    const { namespace, sandboxId, cloudflare } = resolved\n    const id = sandboxId ?? `cloudflare-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`\n    const getSandbox = (await loadCloudflareSandbox() as CloudflareSandboxSDK).getSandbox\n    const stub = getSandbox(namespace, id, cloudflare)\n    return new CloudflareSandboxAdapter(id, stub)\n  }\n\n  throw new Error(`Unknown sandbox provider: ${resolved.name}`)\n}\n\ntype ResolvedProvider =\n  | { name: 'vercel', runtime?: string, timeout?: number, cpu?: number }\n  | { name: 'cloudflare', namespace?: DurableObjectNamespaceLike, sandboxId?: string, cloudflare?: CloudflareSandboxOptions }\n\nfunction resolveProvider(provider: SandboxProvider | 'auto' | { name: 'vercel', runtime?: string, timeout?: number, cpu?: number } | { name: 'cloudflare', namespace: DurableObjectNamespaceLike, sandboxId?: string, cloudflare?: CloudflareSandboxOptions } | undefined): ResolvedProvider {\n  if (provider && provider !== 'auto') {\n    if (typeof provider === 'string') {\n      return provider === 'cloudflare' ? { name: 'cloudflare' } : { name: 'vercel' }\n    }\n    return provider\n  }\n\n  if (isWorkerd || envProvider === 'cloudflare_workers' || envProvider === 'cloudflare_pages')\n    return { name: 'cloudflare' }\n  if (envProvider === 'vercel')\n    return { name: 'vercel' }\n\n  if (typeof process !== 'undefined') {\n    if (process.env.CLOUDFLARE_WORKER || process.env.CF_PAGES)\n      return { name: 'cloudflare' }\n    if (process.env.VERCEL || process.env.VERCEL_ENV)\n      return { name: 'vercel' }\n  }\n\n  throw new Error('Unable to auto-detect sandbox provider. Pass { provider }.')\n}\n", "import { Sandbox } from '@cloudflare/sandbox'\nimport { createSandbox } from '../../src/sandbox/index.js'\nimport type { DurableObjectNamespaceLike } from '../../src/sandbox/types.js'\n\nexport { Sandbox }\n\ninterface Env {\n  SANDBOX: DurableObjectNamespaceLike\n}\n\nexport default {\n  async fetch(req: Request, env: Env): Promise<Response> {\n    const url = new URL(req.url)\n\n    if (url.pathname === '/api/health') {\n      return Response.json({ ok: true, provider: 'cloudflare', timestamp: new Date().toISOString() })\n    }\n\n    if (url.pathname !== '/api/sandbox') {\n      return new Response('Not found', { status: 404 })\n    }\n\n    const start = Date.now()\n    try {\n      const sandbox = await createSandbox({\n        provider: {\n          name: 'cloudflare',\n          namespace: env.SANDBOX,\n        },\n      })\n      try {\n        const exec = await sandbox.exec('echo', ['Hello from sandbox!'])\n        await sandbox.writeFile('/tmp/test.txt', 'File content works!')\n        const content = await sandbox.readFile('/tmp/test.txt')\n\n        return Response.json({\n          provider: 'cloudflare',\n          exec,\n          content,\n          elapsed: Date.now() - start,\n          timestamp: new Date().toISOString(),\n        })\n      }\n      finally {\n        await sandbox.stop()\n      }\n    }\n    catch (error) {\n      return Response.json({\n        error: error instanceof Error ? error.message : String(error),\n        elapsed: Date.now() - start,\n        timestamp: new Date().toISOString(),\n      }, { status: 500 })\n    }\n  },\n}\n"],
  "mappings": "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",
  "names": ["GitLogger", "CloudflareLogger", "LogLevelEnum", "TraceContext", "i", "i", "_", "err", "r", "errorResponse: ErrorResponse<TContext>", "response: Response", "request: WSRequest", "sseData: string", "errorData: NewErrorResponse", "data: ExecuteRequest", "data: GitCheckoutRequest", "lastError: Error | undefined", "data: StartProcessRequest", "clientOptions: HttpClientOptions", "code?: string", "provider: BucketProvider | null", "s3fsArgs: string[]", "request: Request", "port: number | undefined", "error: unknown", "result: ExecResult", "timeoutId: ReturnType<typeof setTimeout> | undefined", "timeoutPromise: Promise<never> | undefined", "_", "token: string", "p", "t", "a", "b"]
}
